{
  "name": "Is_It_Fresh",
  "createVersion": "2017-08-12",
  "description": "Refrigerator Monitor for temperature, humidity, door light, and air quality.\nPlace in refrigerator and use smartphone or tablet to view reports.",
  "lastModified": "2018-02-13T00:39:19.386Z",
  "created": "2018-02-13T00:39:19.386Z",
  "meta": {
    "projectTypeName": "NXP Rapid IoT",
    "projectTypeId": "NxpRpk"
  },
  "planes": {
    "NXP Rapid IoT": {
      "type": "mcuxpresso",
      "compilerVersion": "latest",
      "variants": [
        "NxpRpk"
      ],
      "meta": {},
      "elements": [
        {
          "name": "AirQualityCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), ATMO_PROPERTY(AirQualityCharacteristic, readDataType), ATMO_PROPERTY(AirQualityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AirQualityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AirQualityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e75-a4ff-6f0cd50005f4",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 282.50006103515625,
            "editorY": 473,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "TemperatureCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), ATMO_PROPERTY(TemperatureCharacteristic, readDataType), ATMO_PROPERTY(TemperatureCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(TemperatureCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(TemperatureCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e76-a4ff-6f0cd50005f1",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 356.50006103515625,
            "editorY": 0,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "HumidityCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(HumidityCharacteristic, writeDataType), ATMO_PROPERTY(HumidityCharacteristic, readDataType), ATMO_PROPERTY(HumidityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(HumidityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(HumidityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(HumidityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e77-a4ff-6f0cd50005f2",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 355.50006103515625,
            "editorY": 179,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "DoorLightCharacteristic",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(DoorLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(DoorLightCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(DoorLightCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(DoorLightCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(DoorLightCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(DoorLightCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(DoorLightCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(DoorLightCharacteristic, writeDataType), ATMO_PROPERTY(DoorLightCharacteristic, readDataType), ATMO_PROPERTY(DoorLightCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(DoorLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(DoorLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(DoorLightCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\tATMO_VARIABLE(DoorLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(DoorLightCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(DoorLightCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\tATMO_VARIABLE(DoorLightCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(DoorLightCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e79-a4ff-6f0cd50005f3",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 282.50006103515625,
            "editorY": 355,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "SX9500Touch",
          "type": "EmbeddedSX9500",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(SX9500Touch, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(SX9500Touch, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(SX9500Touch, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(SX9500Touch, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(SX9500Touch, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(SX9500Touch, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(SX9500Touch, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(SX9500Touch, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(SX9500Touch, pressRight));\n\treturn ATMO_Status_Success;",
              "getTouchData": "",
              "pressUp": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressDown": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressLeft": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressRight": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "getTouchData": false,
              "pressUp": false,
              "pressDown": false,
              "pressLeft": false,
              "pressRight": false
            },
            "i2cInstance": 1,
            "gpioInstance": 0,
            "interruptEnabled": true,
            "interruptGpio": "PTA9",
            "i2cAddress": "0x28"
          },
          "meta": {
            "editorX": 1079.33349609375,
            "editorY": 33,
            "lastTrigger": "rightPressed"
          },
          "triggers": {
            "triggered": [],
            "touchDataRead": [],
            "upPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateUp"
              }
            ],
            "downPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateDown"
              }
            ],
            "leftPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateLeft"
              }
            ],
            "rightPressed": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedPageController",
                "targetAbility": "navigateRight"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "getTouchData": false,
            "pressUp": false,
            "pressDown": false,
            "pressLeft": false,
            "pressRight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "getTouchData",
              "triggers": [
                "touchDataRead"
              ]
            },
            {
              "name": "pressUp",
              "triggers": [
                "upPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressDown",
              "triggers": [
                "downPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressLeft",
              "triggers": [
                "leftPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressRight",
              "triggers": [
                "rightPressed",
                "touchDataRead"
              ]
            }
          ]
        },
        {
          "name": "Temperature_P",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(Temperature_P, x), ATMO_PROPERTY(Temperature_P, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(Temperature_P, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(Temperature_P, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(Temperature_P, topRightButtonEnabled),\n    ATMO_PROPERTY(Temperature_P,bottomRightButtonEnabled), ATMO_PROPERTY(Temperature_P, topLeftButtonEnabled), ATMO_PROPERTY(Temperature_P, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(Temperature_P, x);\n    config.x = ATMO_PROPERTY(Temperature_P, x);\n    config.y = ATMO_PROPERTY(Temperature_P, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(Temperature_P, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(Temperature_P, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(Temperature_P, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(Temperature_P, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(Temperature_P, spanX);\n\tconfig.spanY = ATMO_PROPERTY(Temperature_P, spanY);\n    config.title = ATMO_PROPERTY(Temperature_P, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(Temperature_P, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(Temperature_P, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(Temperature_P, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(Temperature_P, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), ATMO_ABILITY(Temperature_P, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 1, ATMO_ABILITY(Temperature_P, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 2, ATMO_ABILITY(Temperature_P, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 3, ATMO_ABILITY(Temperature_P, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Temperature_P,pageHandle), 4, ATMO_ABILITY(Temperature_P, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(Temperature_P, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(Temperature_P,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Temperature",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": 0,
            "y": 0,
            "spanX": 1,
            "spanY": 1,
            "icon": "icon_applications_thermostat",
            "label": "N/A"
          },
          "meta": {
            "editorX": 663.33349609375,
            "editorY": 137,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "EmbeddedPageController",
          "type": "EmbeddedPageController",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_UI_PAGE_CONTROLLER_Config_t config;\n\tconfig.enableUpDownNavLabels = ATMO_PROPERTY(EmbeddedPageController, upDownNavigationLabelsEnabled);\n\tconfig.enableLeftRightNavLabels = ATMO_PROPERTY(EmbeddedPageController, leftRightNavigationLabelsEnabled);\n\tATMO_UI_Page_SetConfiguration(&config);\n    return ATMO_Status_Success;\n\t",
              "displayRootPage": "\n\t\n\tATMO_UI_Page_DisplayRootPage();\n\treturn ATMO_Status_Success;\n\t",
              "navigateUp": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_UP);\n\treturn ATMO_Status_Success;\n\t",
              "navigateDown": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_DOWN);\n\treturn ATMO_Status_Success;\n\t",
              "navigateLeft": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_LEFT);\n\treturn ATMO_Status_Success;\n\t",
              "navigateRight": "\n\tATMO_UI_Page_ProcessNavButton(ATMO_UI_PAGE_NAV_RIGHT);\n\treturn ATMO_Status_Success;\n\t",
              "processTopRightButton": "\n\tATMO_UI_Page_ProcessUserButton(1);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomRightButton": "\n\tATMO_UI_Page_ProcessUserButton(2);\n\treturn ATMO_Status_Success;\n\t",
              "processTopLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(3);\n\treturn ATMO_Status_Success;\n\t",
              "processBottomLeftButton": "\n\tATMO_UI_Page_ProcessUserButton(4);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "displayRootPage": false,
              "navigateUp": false,
              "navigateDown": false,
              "navigateLeft": false,
              "navigateRight": false,
              "processTopRightButton": false,
              "processBottomRightButton": false,
              "processTopLeftButton": false,
              "processBottomLeftButton": false
            },
            "upDownNavigationLabelsEnabled": true,
            "leftRightNavigationLabelsEnabled": true
          },
          "meta": {
            "editorX": 1222.33349609375,
            "editorY": 29,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "navigateUp": [],
            "navigateDown": [],
            "navigateLeft": [],
            "navigateRight": [],
            "processTopRightButton": [],
            "processBottomRightButton": [],
            "processTopLeftButton": [],
            "processBottomLeftButton": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "displayRootPage": false,
            "navigateUp": false,
            "navigateDown": false,
            "navigateLeft": false,
            "navigateRight": false,
            "processTopRightButton": false,
            "processBottomRightButton": false,
            "processTopLeftButton": false,
            "processBottomLeftButton": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "displayRootPage",
              "triggers": []
            },
            {
              "name": "navigateUp",
              "triggers": [
                "navigateUp"
              ]
            },
            {
              "name": "navigateDown",
              "triggers": [
                "navigateDown"
              ]
            },
            {
              "name": "navigateLeft",
              "triggers": [
                "navigateLeft"
              ]
            },
            {
              "name": "navigateRight",
              "triggers": [
                "navigateRight"
              ]
            },
            {
              "name": "processTopRightButton",
              "triggers": [
                "processTopRightButton"
              ]
            },
            {
              "name": "processBottomRightButton",
              "triggers": [
                "processBottomRightButton"
              ]
            },
            {
              "name": "processTopLeftButton",
              "triggers": [
                "processTopLeftButton"
              ]
            },
            {
              "name": "processBottomLeftButton",
              "triggers": [
                "processBottomLeftButton"
              ]
            }
          ]
        },
        {
          "name": "Humidity_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(Humidity_Pag, x), ATMO_PROPERTY(Humidity_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(Humidity_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(Humidity_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(Humidity_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(Humidity_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(Humidity_Pag, topLeftButtonEnabled), ATMO_PROPERTY(Humidity_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(Humidity_Pag, x);\n    config.x = ATMO_PROPERTY(Humidity_Pag, x);\n    config.y = ATMO_PROPERTY(Humidity_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(Humidity_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(Humidity_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(Humidity_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(Humidity_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(Humidity_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(Humidity_Pag, spanY);\n    config.title = ATMO_PROPERTY(Humidity_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(Humidity_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(Humidity_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(Humidity_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(Humidity_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), ATMO_ABILITY(Humidity_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 1, ATMO_ABILITY(Humidity_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 2, ATMO_ABILITY(Humidity_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 3, ATMO_ABILITY(Humidity_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(Humidity_Pag,pageHandle), 4, ATMO_ABILITY(Humidity_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(Humidity_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(Humidity_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Humidity",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "1",
            "y": 0,
            "spanX": 1,
            "spanY": 1,
            "icon": "icon_applications_humidity",
            "label": "N/A"
          },
          "meta": {
            "editorX": 667.33349609375,
            "editorY": 220,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "DoorLight_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(DoorLight_Pag, x), ATMO_PROPERTY(DoorLight_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(DoorLight_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(DoorLight_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(DoorLight_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(DoorLight_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(DoorLight_Pag, topLeftButtonEnabled), ATMO_PROPERTY(DoorLight_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(DoorLight_Pag, x);\n    config.x = ATMO_PROPERTY(DoorLight_Pag, x);\n    config.y = ATMO_PROPERTY(DoorLight_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(DoorLight_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(DoorLight_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(DoorLight_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(DoorLight_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(DoorLight_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(DoorLight_Pag, spanY);\n    config.title = ATMO_PROPERTY(DoorLight_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(DoorLight_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(DoorLight_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(DoorLight_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(DoorLight_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(DoorLight_Pag,pageHandle), ATMO_ABILITY(DoorLight_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(DoorLight_Pag,pageHandle), 1, ATMO_ABILITY(DoorLight_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(DoorLight_Pag,pageHandle), 2, ATMO_ABILITY(DoorLight_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(DoorLight_Pag,pageHandle), 3, ATMO_ABILITY(DoorLight_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(DoorLight_Pag,pageHandle), 4, ATMO_ABILITY(DoorLight_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(DoorLight_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(DoorLight_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Door Light",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "3",
            "y": 0,
            "spanX": 1,
            "spanY": 1,
            "icon": "icon_applications_light",
            "label": "N/A"
          },
          "meta": {
            "editorX": 665.3333740234375,
            "editorY": 385,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "AirQuality_Pag",
          "type": "EmbeddedIconLabelDisplay",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "displayPage": "\n\tATMO_UI_Page_DisplayPageByCoord(ATMO_PROPERTY(AirQuality_Pag, x), ATMO_PROPERTY(AirQuality_Pag, y), false);\n\treturn ATMO_Status_Success;\n\t",
              "onDisplayed": "\n\treturn ATMO_Status_Success;\n    ",
              "topRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomRightButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "topLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "bottomLeftButtonPressed": "\n\treturn ATMO_Status_Success;\n\t",
              "setup": "\n    ATMO_UI_PAGE_Config_t config;\n\tconfig.hidden = ATMO_PROPERTY(AirQuality_Pag, pageHidden);\n\tconfig.textColor = ATMO_PROPERTY(AirQuality_Pag, textColor);\n    config.activeButtons = ATMO_UI_Page_GetButtonMask(ATMO_PROPERTY(AirQuality_Pag, topRightButtonEnabled),\n    ATMO_PROPERTY(AirQuality_Pag,bottomRightButtonEnabled), ATMO_PROPERTY(AirQuality_Pag, topLeftButtonEnabled), ATMO_PROPERTY(AirQuality_Pag, bottomLeftButtonEnabled));\n\tconfig.x = ATMO_PROPERTY(AirQuality_Pag, x);\n    config.x = ATMO_PROPERTY(AirQuality_Pag, x);\n    config.y = ATMO_PROPERTY(AirQuality_Pag, y);\n\tstrncpy(config.topLeftButtonLabel, ATMO_PROPERTY(AirQuality_Pag, topLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.topRightButtonLabel, ATMO_PROPERTY(AirQuality_Pag, topRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomLeftButtonLabel, ATMO_PROPERTY(AirQuality_Pag, bottomLeftButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n\tstrncpy(config.bottomRightButtonLabel, ATMO_PROPERTY(AirQuality_Pag, bottomRightButtonLabel), ATMO_BUTTON_LABEL_MAXLEN);\n    config.spanX = ATMO_PROPERTY(AirQuality_Pag, spanX);\n\tconfig.spanY = ATMO_PROPERTY(AirQuality_Pag, spanY);\n    config.title = ATMO_PROPERTY(AirQuality_Pag, pageTitle);\n    config.titleHidden = ATMO_PROPERTY(AirQuality_Pag, titleHidden);\n\tATMO_UI_SINGLEICONTEXT_Init(&config);\n\tATMO_VARIABLE(AirQuality_Pag, pageHandle) = config.templateInstance;\n    ATMO_UI_SINGLEICONTEXT_SetMainText(config.templateInstance, ATMO_PROPERTY(AirQuality_Pag, label));\n    ATMO_UI_SINGLEICONTEXT_SetIcon(config.templateInstance, ATMO_PROPERTY(AirQuality_Pag, icon));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnDisplayedAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), ATMO_ABILITY(AirQuality_Pag, onDisplayed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 1, ATMO_ABILITY(AirQuality_Pag, topRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 2, ATMO_ABILITY(AirQuality_Pag, bottomRightButtonPressed));\n\tATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 3, ATMO_ABILITY(AirQuality_Pag, topLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterButtonAbilityHandle(ATMO_VARIABLE(AirQuality_Pag,pageHandle), 4, ATMO_ABILITY(AirQuality_Pag, bottomLeftButtonPressed));\n    ATMO_UI_SINGLEICONTEXT_RegisterOnLeaveAbilityHandle(config.templateInstance, ATMO_ABILITY(AirQuality_Pag, onLeave));\n\treturn ATMO_Status_Success;\n    ",
              "onLeave": "\n\treturn ATMO_Status_Success;\n\t",
              "setLabel": "\n    char label[32];\n    if(ATMO_GetString(in, label, 32) == ATMO_Status_Success)\n    {\n        ATMO_UI_SINGLEICONTEXT_SetMainText(ATMO_VARIABLE(AirQuality_Pag,pageHandle), label);\n    }\n    else\n    {\n        return ATMO_Status_Fail;\n    }\n\n    return ATMO_Status_Success;\n    "
            },
            "variables": {
              "pageHandle": {
                "type": "ATMO_DriverInstanceHandle_t"
              }
            },
            "embeddedPropertyConversions": {
              "pageTitle": "string",
              "topRightButtonLabel": "string",
              "bottomRightButtonLabel": "string",
              "topLeftButtonLabel": "string",
              "bottomLeftButtonLabel": "string",
              "label": "string"
            },
            "codeUserChanged": {
              "onDisplayed": false,
              "topRightButtonPressed": false,
              "bottomRightButtonPressed": false,
              "topLeftButtonPressed": false,
              "bottomLeftButtonPressed": false,
              "setup": false,
              "onLeave": false,
              "setLabel": false
            },
            "textColor": "GUI_BLACK",
            "pageTitle": "Air TVOC",
            "titleHidden": false,
            "pageHidden": false,
            "topRightButtonLabel": "",
            "topRightButtonEnabled": false,
            "bottomRightButtonLabel": "",
            "bottomRightButtonEnabled": false,
            "topLeftButtonLabel": "",
            "topLeftButtonEnabled": false,
            "bottomLeftButtonLabel": "",
            "bottomLeftButtonEnabled": false,
            "x": "5",
            "y": 0,
            "spanX": "4",
            "spanY": 1,
            "icon": "icon_applications_airq",
            "label": ""
          },
          "meta": {
            "editorX": 667.1666870117188,
            "editorY": 471,
            "lastTrigger": "onDisplayed"
          },
          "triggers": {
            "triggered": [],
            "onDisplayed": [],
            "topRightButtonPressed": [],
            "bottomRightButtonPressed": [],
            "topLeftButtonPressed": [],
            "bottomLeftButtonPressed": [],
            "onLeave": []
          },
          "interruptAbilities": {
            "trigger": false,
            "displayPage": false,
            "onDisplayed": false,
            "topRightButtonPressed": false,
            "bottomRightButtonPressed": false,
            "topLeftButtonPressed": false,
            "bottomLeftButtonPressed": false,
            "setup": false,
            "onLeave": false,
            "setLabel": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "displayPage",
              "triggers": []
            },
            {
              "name": "onDisplayed",
              "triggers": [
                "onDisplayed"
              ]
            },
            {
              "name": "topRightButtonPressed",
              "triggers": [
                "topRightButtonPressed"
              ]
            },
            {
              "name": "bottomRightButtonPressed",
              "triggers": [
                "bottomRightButtonPressed"
              ]
            },
            {
              "name": "topLeftButtonPressed",
              "triggers": [
                "topLeftButtonPressed"
              ]
            },
            {
              "name": "bottomLeftButtonPressed",
              "triggers": [
                "bottomLeftButtonPressed"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "onLeave",
              "triggers": [
                "onLeave"
              ]
            },
            {
              "name": "setLabel",
              "triggers": []
            }
          ]
        },
        {
          "name": "Interval5sec",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval5sec, instance), \n\t\tATMO_ABILITY(Interval5sec, interval), \n\t\tATMO_PROPERTY(Interval5sec, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": 0,
            "time": "5000"
          },
          "meta": {
            "editorX": 34.16668701171875,
            "editorY": 231,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "ENS210TemperatureHumidity",
                "targetAbility": "readTemperature"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "ENS210TemperatureHumidity",
                "targetAbility": "readHumidity"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CCS811AirQuality",
                "targetAbility": "readTVOC"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "TSL2572DoorLight",
          "type": "EmbeddedTSL2572",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(TSL2572DoorLight, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(TSL2572DoorLight, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readAmbientLight": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readAmbientLight": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x39"
          },
          "meta": {
            "editorX": 161.16668701171875,
            "editorY": 292,
            "lastTrigger": "ambientLightRead"
          },
          "triggers": {
            "triggered": [],
            "ambientLightRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "DoorLightCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetLightStr",
                "targetAbility": "trigger"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readAmbientLight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readAmbientLight",
              "triggers": [
                "ambientLightRead"
              ]
            }
          ]
        },
        {
          "name": "GetTempStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat temp = 0;\n\tATMO_GetFloat(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%.1f C\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 558.3333740234375,
            "editorY": 101,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Temperature_P",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "GetHumidityStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tfloat temp = 0;\n\tATMO_GetFloat(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%.1f %%rh\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 572.3333740234375,
            "editorY": 188,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Humidity_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "GetLightStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tint temp = 0;\n\tATMO_GetInt(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%d lx\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 534.3333740234375,
            "editorY": 392,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "DoorLight_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "GetAirQualityStr",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tint temp = 0;\n\tATMO_GetInt(in, &temp);\n\tchar str[32];\n\tsprintf(str, \"%d ppb\", temp);\n\tATMO_CreateValueString(out, str);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 540.3333740234375,
            "editorY": 465,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQuality_Pag",
                "targetAbility": "setLabel"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "ENS210TemperatureHumidity",
          "type": "EmbeddedENS210",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(ENS210TemperatureHumidity, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(ENS210TemperatureHumidity, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(ENS210TemperatureHumidity, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTemperature": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readHumidity": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTemperature": false,
              "readHumidity": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x43",
            "tempCalibrationOffset": -7
          },
          "meta": {
            "editorX": 165.3333740234375,
            "editorY": 14,
            "lastTrigger": "humidityRead"
          },
          "triggers": {
            "triggered": [],
            "temperatureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetTempStr",
                "targetAbility": "trigger"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TemperatureCharacteristic",
                "targetAbility": "setValue"
              }
            ],
            "humidityRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "HumidityCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetHumidityStr",
                "targetAbility": "trigger"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTemperature": false,
            "readHumidity": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTemperature",
              "triggers": [
                "temperatureRead"
              ]
            },
            {
              "name": "readHumidity",
              "triggers": [
                "humidityRead"
              ]
            }
          ]
        },
        {
          "name": "CCS811AirQuality",
          "type": "EmbeddedCCS811",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(CCS811AirQuality, operatingMode);\n\tconfig.address = ATMO_PROPERTY(CCS811AirQuality, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(CCS811AirQuality, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTVOC": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readCO2": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTVOC": false,
              "readCO2": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x5A",
            "operatingMode": "1"
          },
          "meta": {
            "editorX": 157.3333740234375,
            "editorY": 455,
            "lastTrigger": "TVOCRead"
          },
          "triggers": {
            "triggered": [],
            "TVOCRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQualityCharacteristic",
                "targetAbility": "setValue"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "GetAirQualityStr",
                "targetAbility": "trigger"
              }
            ],
            "CO2Read": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTVOC": false,
            "readCO2": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTVOC",
              "triggers": [
                "TVOCRead"
              ]
            },
            {
              "name": "readCO2",
              "triggers": [
                "CO2Read"
              ]
            }
          ]
        },
        {
          "name": "EmbeddedNxpRpkBacklight",
          "type": "EmbeddedNxpRpkBacklight",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    Backlight_SetLevel(ATMO_PROPERTY(EmbeddedNxpRpkBacklight, initialSetting));\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightOff": "\n    Backlight_SetLevel(BLIGHT_LEVEL_OFF);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightLow": "\n    Backlight_SetLevel(BLIGHT_LEVEL_LOW);\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightMedium": "\n    Backlight_SetLevel(BLIGHT_LEVEL_MEDIUM);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightHigh": "\n    Backlight_SetLevel(BLIGHT_LEVEL_HIGH);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setBacklightOff": false,
              "setBacklightLow": false,
              "setBacklightMedium": false,
              "setBacklightHigh": false
            },
            "initialSetting": "BLIGHT_LEVEL_LOW"
          },
          "meta": {
            "editorX": 284.3333740234375,
            "editorY": 608,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "backlightSet": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setBacklightOff": false,
            "setBacklightLow": false,
            "setBacklightMedium": false,
            "setBacklightHigh": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setBacklightOff",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightLow",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightMedium",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightHigh",
              "triggers": [
                "backlightSet"
              ]
            }
          ]
        },
        {
          "name": "SX9500Touch1",
          "type": "EmbeddedSX9500",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(SX9500Touch1, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(SX9500Touch1, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(SX9500Touch1, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(SX9500Touch1, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(SX9500Touch1, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(SX9500Touch1, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(SX9500Touch1, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(SX9500Touch1, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(SX9500Touch1, pressRight));\n\treturn ATMO_Status_Success;",
              "getTouchData": "",
              "pressUp": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressDown": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressLeft": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;",
              "pressRight": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "getTouchData": false,
              "pressUp": false,
              "pressDown": false,
              "pressLeft": false,
              "pressRight": false
            },
            "i2cInstance": 1,
            "gpioInstance": 0,
            "interruptEnabled": true,
            "interruptGpio": "PTA9",
            "i2cAddress": "0x28"
          },
          "meta": {
            "editorX": 125.3333740234375,
            "editorY": 613,
            "lastTrigger": "touchDataRead"
          },
          "triggers": {
            "triggered": [],
            "touchDataRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightHigh"
              }
            ],
            "upPressed": [],
            "downPressed": [],
            "leftPressed": [],
            "rightPressed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "getTouchData": false,
            "pressUp": false,
            "pressDown": false,
            "pressLeft": false,
            "pressRight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "getTouchData",
              "triggers": [
                "touchDataRead"
              ]
            },
            {
              "name": "pressUp",
              "triggers": [
                "upPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressDown",
              "triggers": [
                "downPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressLeft",
              "triggers": [
                "leftPressed",
                "touchDataRead"
              ]
            },
            {
              "name": "pressRight",
              "triggers": [
                "rightPressed",
                "touchDataRead"
              ]
            }
          ]
        },
        {
          "name": "Interval1",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval1, instance), \n\t\tATMO_ABILITY(Interval1, interval), \n\t\tATMO_PROPERTY(Interval1, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": 0,
            "time": "10000"
          },
          "meta": {
            "editorX": 119.3333740234375,
            "editorY": 709,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "EmbeddedNxpRpkBacklight",
                "targetAbility": "setBacklightOff"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "Interval1sec",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval1sec, instance), \n\t\tATMO_ABILITY(Interval1sec, interval), \n\t\tATMO_PROPERTY(Interval1sec, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": 0,
            "time": "1000"
          },
          "meta": {
            "editorX": 31.16668701171875,
            "editorY": 379,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TSL2572DoorLight",
                "targetAbility": "readAmbientLight"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        }
      ],
      "libraries": {
        "sx9500": {
          "libName": "sx9500",
          "manufacturer": "Semtech",
          "description": "SX9500 Capacitive Touch Sensor",
          "type": "Touch Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "gpio"
          ],
          "elements": [
            {
              "name": "SX9500Touch",
              "type": "EmbeddedSX9500",
              "icon": "EmbeddedTouch.svg",
              "defaultAbility": "getTouchData",
              "defaultTrigger": "touchDataRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "code": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(undefined, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(undefined, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(undefined, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(undefined, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(undefined, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(undefined, pressRight));\n\treturn ATMO_Status_Success;"
                },
                {
                  "name": "getTouchData",
                  "triggers": [
                    "touchDataRead"
                  ],
                  "code": ""
                },
                {
                  "name": "pressUp",
                  "triggers": [
                    "upPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressDown",
                  "triggers": [
                    "downPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressLeft",
                  "triggers": [
                    "leftPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressRight",
                  "triggers": [
                    "rightPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interruptEnabled",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "interruptGpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x28"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedSX9500": "SX9500 Touch Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "interruptGpio": "Interrupt GPIO Pin",
                  "interruptEnabled": "Touch Interrupt Enabled",
                  "gpioInstance": "GPIO Driver Instance",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "getTouchData": "Get Current Touch Data",
                  "touchDataRead": "Touch Data Read",
                  "pressUp": "Press Up",
                  "upPressed": "Up Pressed",
                  "pressDown": "Press Down",
                  "downPressed": "Down Pressed",
                  "pressLeft": "Press Left",
                  "leftPressed": "Left Pressed",
                  "pressRight": "Press Right",
                  "rightPressed": "Right Pressed"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "sx9500.h": "#ifndef __ATMO_SX9500_H_\n#define __ATMO_SX9500_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n#include \"../gpio/gpio.h\"\n\ntypedef enum {\n    ATMO_SX9500_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_SX9500_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_SX9500_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_SX9500_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_SX9500_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_SX9500_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    bool interruptEnabled;\n    ATMO_GPIO_Device_Pin_t interruptPin;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    ATMO_DriverInstanceHandle_t gpioDriverInstance;\n} ATMO_SX9500_Config_t;\n\ntypedef struct {\n\tbool downPressed;\n\tbool upPressed;\n\tbool leftPressed;\n\tbool rightPressed;\n} SX9500_TouchState_t;\n\ntypedef enum {\n\tSX9500_Touched_Any = 0,\n\tSX9500_Touched_Down,\n\tSX9500_Touched_Right,\n\tSX9500_Touched_Up,\n\tSX9500_Touched_Left,\n\tSX9500_Touched_NumEvents,\n} SX9500_TouchEvent_t;\n\n\n/**\n * Initialize SX9500 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config);\n\n/**\n * Get current touch sensor state\n *\n * @param[out] touchState\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState);\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle);\n\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb);\n\n\n#endif\n\n",
                "sx9500_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.h\n * This is the header file for the SX9500 touch controller driver.\n */\n\n#ifndef SX9500_INTERNAL_H_\n#define SX9500_INTERNAL_H_\n\n/*!\n * @addtogroup sx9500 SX9500 touch controller API\n * @{\n */\n\n#include \"../app_src/atmosphere_platform.h\"\n\n\n#define SX9500_I2C_ADDRESS                          0x28\n\n#define SX9500_REG_IRQSRC                           0x00\n#define SX9500_REG_STAT                             0x01\n#define SX9500_REG_IRQMSK                           0x03\n#define SX9500_REG_PROXCTRL0                        0x06\n#define SX9500_REG_PROXCTRL1                        0x07\n#define SX9500_REG_PROXCTRL2                        0x08\n#define SX9500_REG_PROXCTRL3                        0x09\n#define SX9500_REG_PROXCTRL4                        0x0A\n#define SX9500_REG_PROXCTRL5                        0x0B\n#define SX9500_REG_PROXCTRL6                        0x0C\n#define SX9500_REG_PROXCTRL7                        0x0D\n#define SX9500_REG_PROXCTRL8                        0x0E\n#define SX9500_REG_SENSORSEL                        0x20\n#define SX9500_REG_USEMSB                           0x21\n#define SX9500_REG_USELSB                           0x22\n#define SX9500_REG_AVGMSB                           0x23\n#define SX9500_REG_AVGLSB                           0x24\n#define SX9500_REG_DIFFMSB                          0x25\n#define SX9500_REG_DIFFLSB                          0x26\n#define SX9500_REG_OFFSETMSB                        0x27\n#define SX9500_REG_OFFSETLSB                        0x28\n#define SX9500_REG_RESET                            0x7F\n \n#define SX9500_RESET_CMD                            0xDE\n \n/*! @brief Status return codes. */\ntypedef enum\n{\n    SX9500_SUCCESS,\n    SX9500_I2C_ERROR,\n    SX9500_INTERNAL_ERROR,\n\tSX9500_NOINIT_ERROR\n} SX9500_status;\n\ntypedef union {\n    struct {    // sx9500 register 0x00\n        uint8_t txen_stat   : 1;    // 0\n        uint8_t reserved    : 2;    // 1,2\n        uint8_t conv_done   : 1;    // 3\n        uint8_t comp_done   : 1;    // 4\n        uint8_t far         : 1;    // 5\n        uint8_t close       : 1;    // 6\n        uint8_t reset       : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegIrqSrc_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x01\n        uint8_t compstat         : 4;    // 0,1,2,3\n        uint8_t proxstat0        : 1;    // 4\n        uint8_t proxstat1        : 1;    // 5\n        uint8_t proxstat2        : 1;    // 6\n        uint8_t proxstat3        : 1;    // 7\n   } bits;\n    uint8_t octet;\n} RegStat_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x06\n        uint8_t sensor_en   : 4;    // 0,1,2,3\n        uint8_t scan_period : 3;    // 4,5,6\n        uint8_t reserved    : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl0_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x09\n        uint8_t raw_filt    : 2;    // 0,1\n        uint8_t reserved    : 2;    // 2,3\n        uint8_t doze_period : 2;    // 4,5\n        uint8_t doze_en     : 1;    // 6\n        uint8_t res7        : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl3_t;\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _sx9500_fct_t\n{\n\t/** Read hardware function */\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\n    /** Write hardware register, 8bit aligned function */\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\n    /** Wait function **/\n    void (*WaitMs)(uint32_t tms);\n} sx9500_fct_t, *ptsx9500_fct_t;\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize SX9500 driver.\n *\n * @param FCT Pointer to a structure with external functions\n */\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT);\n\n/*!\n * @brief De-initialize SX9500 driver.\n *\n */\nvoid SX9500_Deinit_Driver();\n\n/*!\n * @brief Initialize SX9500 hardware.\n *\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_Init_Hw();\n\n/*!\n * @brief Get information for selected sensor.\n *\n * @param  CSn Selected sensor (0-3)\n * @param  buf Pointer to an array with PROXUSEFUL/PROXAVG/PROXDIFF values\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf);\n\n/*!\n * @brief Get power mode.\n *\n * @return Power mode: active (true/1) or low power (false/0)\n */\nbool SX9500_get_active();\n\n/*!\n * @brief Set power mode.\n *\n * @param  bool Power mode: active (true/1) or low power (false/0)\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_set_active(bool);\n\n/*!\n * @brief Function returning the triggered capacitive sensing interface.\n * @note Returns 0xFF if no interface has been triggered.\n *\n * @param  CSi Pointer to sensing interface index\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi);\n\n/*!\n * @brief Read IRQ Source\n * @note  Used to clear interrupts on SX9500\n *\n * @param irqReg Pointer to store value from IRQ register\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg);\n\n/*!\n * @brief Read Proximity Sensors\n *\n * @param data Pointer to store data from proximity sensor data\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data);\n\n/*! @}*/\n\n#endif\n"
              },
              "objects": {
                "sx9500.c": "#include \"sx9500.h\"\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_SX9500_Config_t config;\n    unsigned int abilityHandle[SX9500_Touched_NumEvents];\n\tbool abilityHandleRegistered[SX9500_Touched_NumEvents];\n    ATMO_Callback_t callback[SX9500_Touched_NumEvents];\n    bool configured;\n} ATMO_SX9500_Priv_Config;\n\nstatic ATMO_SX9500_Priv_Config _ATMO_SX9500_config = {0};\n\nstatic ATMO_I2C_Peripheral_t _ATMO_SX9500_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic uint8_t _ATMO_SX9500_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t _ATMO_SX9500_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic bool ATMO_SX9500_TouchStateToIndex(SX9500_TouchState_t *touchState, uint32_t *index)\n{\n\tbool anyPressed = false;\n\n\tif(touchState->downPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Down;\n\t}\n\tif(touchState->upPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Up;\n\t}\n\tif(touchState->rightPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Right;\n\t}\n\tif(touchState->leftPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Left;\n\t}\n\n\treturn anyPressed;\n}\n\nstatic void ATMO_SX9500_Callback(void *data)\n{\n    RegIrqSrc_t irq;\n    if (SX9500_Read_Irq(&irq.octet) == SX9500_SUCCESS)\n    {\n        if (irq.bits.close || irq.bits.far)\n        {\n        \tSX9500_TouchState_t touchState;\n        \tif(ATMO_SX9500_GetTouchState(&touchState) == ATMO_SX9500_Status_Success)\n        \t{\n        \t\tuint32_t index = 0;\n        \t\tif(ATMO_SX9500_TouchStateToIndex(&touchState, &index))\n        \t\t{\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[SX9500_Touched_Any] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[SX9500_Touched_Any], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[index] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[index], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.callback[SX9500_Touched_Any] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[SX9500_Touched_Any](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t\tif(_ATMO_SX9500_config.callback[index] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[index](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t}\n        \t}\n        \telse\n        \t{\n        \t\treturn ATMO_SX9500_Status_Fail;\n        \t}\n        }\n    }\n    else\n    {\n    \treturn ATMO_SX9500_Status_Fail;\n    }\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_SX9500_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_SX9500_config.configured = false;\n    }\n\n\tsx9500_fct_t fct;\n\tfct.I2C_Read = _ATMO_SX9500_I2CRead_Simple;\n\tfct.I2C_Write = _ATMO_SX9500_I2CWrite_Simple;\n\tfct.WaitMs = ATMO_PLATFORM_DelayMilliseconds;\n\tSX9500_Init_Driver(&fct);\n\tSX9500_Init_Hw();\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_SX9500_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    // Register interrupt\n    if(config->interruptEnabled)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->interruptPin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_SX9500_Callback);\n    }\n\n    memcpy( &_ATMO_SX9500_config.config, config, sizeof(ATMO_SX9500_Config_t) );\n    _ATMO_SX9500_config.configured = true;\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL || !_ATMO_SX9500_config.configured )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_SX9500_config.config, sizeof(ATMO_SX9500_Config_t));\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState)\n{\n\tmemset(touchState, 0, sizeof(SX9500_TouchState_t));\n\n\tRegStat_t dir;\n\tif( SX9500_Read_Proximity_Sensors(&dir.octet) != SX9500_SUCCESS )\n\t{\n\t\treturn ATMO_SX9500_Status_Fail;\n\t}\n\n\tif(dir.octet > 0)\n\t{\n\t\tif(dir.bits.proxstat0)\n\t\t{\n\t\t\ttouchState->downPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat1)\n\t\t{\n\t\t\ttouchState->rightPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat2)\n\t\t{\n\t\t\ttouchState->upPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat3)\n\t\t{\n\t\t\ttouchState->leftPressed = true;\n\t\t}\n\t}\n\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle)\n{\n\t_ATMO_SX9500_config.abilityHandle[event] = abilityHandle;\n\t_ATMO_SX9500_config.abilityHandleRegistered[event] = true;\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb)\n{\n\t_ATMO_SX9500_config.callback[event] = cb;\n\treturn ATMO_SX9500_Status_Success;\n}\n\n\n",
                "sx9500_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.c\n * This is the source file for the SX9500 touch controller driver.\n */\n\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic sx9500_fct_t FCT_SX9500;\nstatic bool m_txen;\n\n/* Define registers that need to be initialized to values different than\n * default\n */\ntypedef struct smtc_reg_data {\n    unsigned char reg;\n    unsigned char val;\n}smtc_reg_data_t;\nstatic smtc_reg_data_t sx9500_i2c_reg_setup[] = {\n    {\n        .reg = SX9500_REG_IRQMSK,\n        .val = 0x60,  /* CLOSEIRQEN[6]=1 (close interrupt is on),            */\n                      /* FARIRQEN[5]=1 (far interrupt is on),                */\n                      /* COMPDONEIRQEN[4]=0 (compensation interrupt is off), */\n                      /* CONVDONEIRQEN[3]=0 (conversion interrupt is off)    */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL1,\n        .val = 0x03,  /* SHIELDEN[7:6]=0 (no shield),              */\n                      /* RANGE[1:0]=3 (small, +/-2.5pF Full Scale) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL2,\n        .val = 0x27,  /* GAIN[6:5]=1 (digital gain x2),          */\n                      /* FREQ[4:3]=0 (83kHz sampling frequency), */\n                      /* RESOLUTION[2:0]=0 (finest resolution)   */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL3,\n        .val = 0x41,  /* DOZEEN[6]=1 (enables doze mode),   */\n                      /* DOZEPERIOD[5:4]=0 (2*scan period), */\n                      /* RAWFILT[1:0]=1 (Low)               */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL4,\n        .val = 0x80,  /* AVGTHRESH[7:0]=0x80 (threshold triggering compensation = +/-128*value (typ between 16384 and 24576) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL5,\n        .val = 0x0F,  /* AVGDEB[7:6]=0 (debounce=off),               */\n                      /* AVGNEGFILT[5:3]=1 (lowest negative filter), */\n                      /* AVGPOSFILT[2:0]=7 (highest positive filter) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL6,\n        .val = 0x06,  /* PROXTHRESH[4:0]=6 (sensitivity=120) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL7,\n        .val = 0x00,  /* AVGCOMPDIS[7]=0 (compensation enabled),      */\n                      /* COMPMETHOD[6]=0 (separate CSx compensation), */\n                      /* HYST[5:4]=0 (hysteresis=32),                 */\n                      /* CLOSEDEB[3:2]=0 (close debouncer=off),       */\n                      /* FARDEB[1:0]=0 (far debouncer=off)            */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL8,\n        .val = 0x08,  /* STUCK[7:4]=0 (stuck timeout=off),                          */\n                      /* COMPPRD[3:0]=8 (periodic compensation every 8*128 samples) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL0,\n        .val = 0x0F,  /* SCANPERIOD[6:4]=0 (scan every 30ms),  */\n                      /* SENSOREN[3:0]=15 (enable all sensors) */\n    },\n};\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\nstatic SX9500_status SX9500_write(uint8_t addr, uint8_t data)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    cmd[1] = data;\n\n    return (SX9500_status)FCT_SX9500.I2C_Write(cmd, 2);\n}\n\nstatic SX9500_status SX9500_read(uint8_t addr, uint8_t *dst_buf, uint32_t length)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    return (SX9500_status)FCT_SX9500.I2C_Read(cmd, 1, dst_buf, length);\n}\n\nstatic SX9500_status SX9500_read_single(uint8_t addr, uint8_t* val)\n{\n    return (SX9500_status)FCT_SX9500.I2C_Read(&addr, 1, val, 1);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT)\n{\n    assert((FCT != NULL) &&\n            (FCT->I2C_Read != NULL) &&\n            (FCT->I2C_Write != NULL) &&\n            (FCT->WaitMs != NULL));\n    FCT_SX9500 = *FCT;\n    initDriverDone = true;\n}\n\nvoid SX9500_Denit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        SX9500_set_active(false); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nSX9500_status SX9500_Init_Hw()\n{\n    int i = 0;\n    uint8_t val;\n    SX9500_status status;\n\n    if (!initDriverDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    // perform a soft reset\n    status = SX9500_write(SX9500_REG_RESET, SX9500_RESET_CMD);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    FCT_SX9500.WaitMs(300); // wait until the reset has finished\n\n    // read IRQSRC to release NIRQ pin\n    status = SX9500_read(SX9500_REG_IRQSRC, &val,1);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    // init I2C registers\n    int lenRegTable = sizeof(sx9500_i2c_reg_setup) / sizeof(smtc_reg_data_t);\n    while (i < lenRegTable)\n    {\n        /* Write all registers/values contained in i2c_reg */\n        status = SX9500_write(sx9500_i2c_reg_setup[i].reg, sx9500_i2c_reg_setup[i].val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        /* Read back value from register and verify write */\n        status = SX9500_read_single(sx9500_i2c_reg_setup[i].reg, &val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        if (val != sx9500_i2c_reg_setup[i].val)\n        {\n            return SX9500_INTERNAL_ERROR;\n        }\n\n        i++;\n    }\n\n    initHwDone = true;\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf)\n{\n    SX9500_status status;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(buf != NULL);\n\n    status = SX9500_write(SX9500_REG_SENSORSEL, CSn);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_USEMSB, buf, 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_AVGMSB, &buf[2], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_DIFFMSB, &buf[4], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    return SX9500_SUCCESS;\n}\n\n// get power mode (active or low power)\nbool SX9500_get_active()\n{\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    return m_txen;\n}\n\n// set active mode or low power mode\nSX9500_status SX9500_set_active(bool en)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    m_txen = en;\n\n    uint8_t val = en ? sx9500_i2c_reg_setup[10].val : 0x00U;\n\n    status = SX9500_write(SX9500_REG_PROXCTRL0, val);\n\n    return status;\n}\n\n// returns the triggered capacitive sensing interface (CS0..CS3)\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi)\n{\n    SX9500_status status = SX9500_SUCCESS;\n    RegIrqSrc_t regirq;\n    RegStat_t prox;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(CSi != NULL);\n\n    *CSi = 0xFF;\n\n    status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    if (regirq.bits.close)\n    {\n        if (prox.bits.proxstat0)\n        {\n            *CSi = 0;\n        }\n        else if (prox.bits.proxstat1)\n        {\n            *CSi = 1;\n        }\n        else if (prox.bits.proxstat2)\n        {\n            *CSi = 2;\n        }\n        else if (prox.bits.proxstat3)\n        {\n            *CSi = 3;\n        }\n    }\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != irqReg)\n    {\n        RegIrqSrc_t regirq;\n        status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n        else\n        {\n            *irqReg = regirq.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != data)\n    {\n        RegStat_t prox;\n        status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            *data = 0xFF;\n            return status;\n        }\n        else\n        {\n            *data = prox.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\n"
              }
            }
          }
        },
        "tsl2572": {
          "libName": "tsl2572",
          "manufacturer": "AMS",
          "description": "Ambient Light Sensor",
          "type": "Ambient Light Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "TSL2572AmbientLight",
              "type": "EmbeddedTSL2572",
              "icon": "EmbeddedAmbientLight.svg",
              "defaultAbility": "readAmbientLight",
              "defaultTrigger": "ambientLightRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAmbientLight",
                  "triggers": [
                    "ambientLightRead"
                  ],
                  "code": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x39"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedTSL2572": "TSL2572 Ambient Light Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readAmbientLight": "Read Ambient Light(lux)",
                  "ambientLightRead": "Ambient Light Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "tsl2572.h": "#ifndef __ATMO_TSL2572_H_\r\n#define __ATMO_TSL2572_H_\r\n\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\ntypedef enum {\r\n    ATMO_TSL2572_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_TSL2572_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_TSL2572_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_TSL2572_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_TSL2572_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_TSL2572_Status_t;\r\n\r\ntypedef struct {\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_TSL2572_Config_t;\r\n\r\n\r\n/**\r\n * Initialize TSL2572 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable TSL2572 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of TSL2572 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get ambient light intensity in lux\r\n *\r\n * @param[out] lightLux\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux);\r\n\r\n\r\n#endif\r\n",
                "tsl2572_internal.h": "/*\r\n * tsl2572.h\r\n *\r\n *  Created on: 25 sept. 2017\r\n *      Author: frq05060\r\n */\r\n\r\n#ifndef TSL2572_H_\r\n#define TSL2572_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n//enum tsl2572_status {\r\n//    sensor_success = 0,\r\n//    sensor_I2C_error = 1,\r\n//    sensor_invalid_ID = 2,\r\n//    sensor_wrong_parameter = 3\r\n//};\r\n\r\ntypedef struct _tsl2572_IoFunc_t\r\n{\r\n  uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\r\n  uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\r\n  void         (*WaitMsec)(uint32_t millisec);\r\n} tsl2572_IoFunc_t, *ptsl2572_IoFunc_t;\r\n\r\n/**\r\n * struct tsl2x7x_default_settings - power on defaults unless\r\n *                                   overridden by platform data.\r\n *  @als_time:              ALS Integration time - multiple of 50mS\r\n *  @als_gain:              Index into the ALS gain table.\r\n *  @als_gain_level:        ALS gain level (When asserted, the 1 and 8 ALS gain (AGAIN) modes are scaled by 0.16)\r\n *  @wait_time:             Time between PRX and ALS cycles\r\n *                          in 2.7 periods\r\n *  @wlong:                 When asserted, the wait cycles are increased by a factor 12 from that programmed in the WTIME register\r\n *  @interrupts_enable:     Enable/Disable als interrupts\r\n *  @persistence:           H/W Filters, Number of 'out of limits'\r\n *                          ADC readings ALS.\r\n *  @als_thresh_low:        CH0 'low' count to trigger interrupt.\r\n *  @als_thresh_high:       CH0 'high' count to trigger interrupt.\r\n *  @als_enable:            This bit actives the two channel ADC\r\n *  @wait_enable:           This bit activates the wait feature.\r\n *  @power_on:              This bit activates the internal oscillator to permit the timers and ADC channels to operate\r\n *  @glass_attenuation:     scaling factor referred to as glass attenuation (GA) can be used to compensate for attenuation\r\n */\r\nstruct tsl2x7x_settings {\r\n    uint8_t als_time;\r\n    uint8_t als_gain;\r\n    bool als_gain_level;\r\n    uint8_t wait_time;\r\n    bool wlong;\r\n    bool  interrupts_enable;\r\n    uint8_t  persistence;\r\n    uint16_t als_thresh_low;\r\n    uint16_t als_thresh_high;\r\n    bool als_enable;\r\n    bool wait_enable;\r\n    bool power_on;\r\n    float glass_attenuation;\r\n};\r\n\r\n/****************************************************************************\r\n * Function Prototypes\r\n ****************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc);\r\nuint8_t TSL2572_Init_HW(void);\r\nuint8_t TSL2572_ReadAmbientLight(float *lux);\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN);\r\nuint8_t TSL2572_ClearALSInterrupt(void);\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS);\r\nuint8_t TSL2572_Enable_ALS(bool AEN);\r\nuint8_t TSL2572_Power_ON(bool PON);\r\nuint8_t TSL2572_Enable_Wait(bool WEN);\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData);\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData);\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG);\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL);\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME);\r\n\r\n#endif /* TSL2572_H_ */\r\n"
              },
              "objects": {
                "tsl2572.c": "#include \"tsl2572.h\"\r\n#include \"tsl2572_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_TSL2572_Config_t config;\r\n    bool configured;\r\n} ATMO_TSL2572_Priv_Config;\r\n\r\nstatic ATMO_TSL2572_Priv_Config _ATMO_TSL2572_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t _ATMO_TSL2572_i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool tsl2572Enabled = true;\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config)\r\n{\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_TSL2572_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n    \t_ATMO_TSL2572_config.configured = false;\r\n    }\r\n\r\n    tsl2572_IoFunc_t io;\r\n    io.I2C_Read = _ATMO_TSL2572_I2CRead_Simple;\r\n    io.I2C_Write = _ATMO_TSL2572_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    TSL2572_Init_Driver(&io);\r\n    TSL2572_Init_HW();\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled)\r\n{\r\n    tsl2572Enabled = enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = tsl2572Enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_TSL2572_i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy( &_ATMO_TSL2572_config.config, config, sizeof(ATMO_TSL2572_Config_t) );\r\n    _ATMO_TSL2572_config.configured = true;\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_TSL2572_config.configured )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_TSL2572_config.config, sizeof(ATMO_TSL2572_Config_t));\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux)\r\n{\r\n    if(!tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n    \r\n\tif( TSL2572_ReadAmbientLight(lightLux) != 0 )\r\n\t{\r\n\t\treturn ATMO_TSL2572_Status_Fail;\r\n\t}\r\n\r\n\treturn ATMO_TSL2572_Status_Success;\r\n}\r\n\r\n\r\n\r\n",
                "tsl2572_internal.c": "/*\r\n * tsl2572.c\r\n *\r\n *  Created on: 25 sept. 2017\r\n *      Author: frq05060\r\n */\r\n\r\n#include \"tsl2572_internal.h\"\r\n\r\n/* TSL2572 Register definitions */\r\n#define TSL2572_I2C_SLAVE_ADDRESS        0x39\r\n#define TSL2572_DEVICE_ID                0x34    // TSL25721\r\n#define TSL2572_REG_ENABLE               0x00\r\n#define TSL2572_REG_ATIME                0x01\r\n#define TSL2572_REG_WTIME                0x03\r\n#define TSL2572_REG_AILTL                0x04\r\n#define TSL2572_REG_AILTH                0x05\r\n#define TSL2572_REG_AIHTL                0x06\r\n#define TSL2572_REG_AIHTH                0x07\r\n#define TSL2572_REG_PERS                 0x0C\r\n#define TSL2572_REG_CONFIG               0x0D\r\n#define TSL2572_REG_CONTROL              0x0F\r\n#define TSL2572_REG_ID                   0x12\r\n#define TSL2572_REG_STATUS               0x13\r\n#define TSL2572_REG_C0DATA               0x14\r\n#define TSL2572_REG_C0DATAH              0x15\r\n#define TSL2572_REG_C1DATA               0x16\r\n#define TSL2572_REG_C1DATAH              0x17\r\n\r\n/* tsl2572 COMMAND register masks */\r\n#define TSL2572_COMMAND_MSK              0x80\r\n#define TSL2572_TYPE_REPEAT_MSK          0x00\r\n#define TSL2572_TYPE_AUTO_INC_MSK        0x20\r\n#define TSL2572_TYPE_SPL_FN_MSK          0x60\r\n#define TSL2572_ADD_ALS_INT_CLR_MSK      0x06\r\n\r\n/* tsl2572 CONTROL register masks */\r\n#define TSL2572_AGAIN_MASK               0x03\r\n\r\n/* tsl2572 CONFIG register masks */\r\n#define TSL2572_AGL_MSK                  0x04\r\n#define TSL2572_WLONG_MSK                0x02\r\n\r\n/* tsl2572 PERS register masks */\r\n#define TSL2572_APERS_MSK                0x0F\r\n\r\n/* tsl2572 ENABLE register masks */\r\n#define TSL2572_AIEN_MSK                 0x10\r\n#define TSL2572_AEN_MSK                  0x02\r\n#define TSL2572_WEN_MSK                  0x08\r\n#define TSL2572_PON_MSK                  0x01\r\n\r\nenum tsl2572_status {\r\n    TSL2572_sensor_success = 0,\r\n    TSL2572_sensor_I2C_error = 1,\r\n    TSL2572_sensor_invalid_ID = 2,\r\n    TSL2572_sensor_wrong_parameter = 3\r\n};\r\n\r\nstatic const struct tsl2x7x_settings tsl2x7x_default_settings = {\r\n        0xDB,\r\n        0,\r\n        true,\r\n        74,\r\n        false,\r\n        true,\r\n        1,\r\n        100,\r\n        300,\r\n        true,\r\n        true,\r\n        true,\r\n        1\r\n};\r\n\r\n/***********************************************************************************/\r\n/* variables                                                                       */\r\n/***********************************************************************************/\r\nstatic tsl2572_IoFunc_t sTSL2572_Func;\r\nuint8_t gain_val = 0;\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_Driver                                                          */\r\n/* wrap the low level function (I2C write, I2C read, WaitMsec)                  */\r\n/* required by TSL2572 driver                                                   */\r\n/* Note : this function does not initialize the HW                              */\r\n/********************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc){\r\n    sTSL2572_Func = *pIoFunc;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_HW                                                              */\r\n/* initialize the HW                                                            */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Init_HW(void){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* check device ID */\r\n    wBuf[0] = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    if (rBuf != TSL2572_DEVICE_ID){\r\n        return TSL2572_sensor_invalid_ID;\r\n    }\r\n\r\n    /* Set ALS gain */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSGain(tsl2x7x_default_settings.als_gain,tsl2x7x_default_settings.als_gain_level)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Set ALS time */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSTime(tsl2x7x_default_settings.als_time)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* configure the wait time */\r\n    if (TSL2572_sensor_success != TSL2572_SetWaitTime(tsl2x7x_default_settings.wait_time,tsl2x7x_default_settings.wlong)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt thresholds */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSThresholds(tsl2x7x_default_settings.als_thresh_low,tsl2x7x_default_settings.als_thresh_high)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt persistence */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSPersistence(tsl2x7x_default_settings.persistence)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* ALS Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_ALS(tsl2x7x_default_settings.als_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Wait Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_Wait(tsl2x7x_default_settings.wait_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Power ON  */\r\n    if (TSL2572_sensor_success != TSL2572_Power_ON(tsl2x7x_default_settings.power_on)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* clear the sensor IRQ status */\r\n    if (TSL2572_sensor_success != TSL2572_ClearALSInterrupt()){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if (TSL2572_sensor_success != TSL2572_EnableALSInterrupts(tsl2x7x_default_settings.interrupts_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAmbientLight                                                     */\r\n/* sample CH0 and CH1 photo_diodes and compute the human eye response to        */\r\n/* light intensity (in lux)                                                     */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAmbientLight(float *lux){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n    int c0,c1;\r\n    float lux1,lux2,cpl;\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    c0 = rBuf[1]<<8 | rBuf[0];\r\n    c1 = rBuf[3]<<8 | rBuf[2];\r\n\r\n    //see TSL2572 datasheet\r\n    cpl = (2.73 * (256-tsl2x7x_default_settings.als_time)) * gain_val / (tsl2x7x_default_settings.glass_attenuation * 60);\r\n    if (tsl2x7x_default_settings.als_gain_level){\r\n        cpl /= 6;\r\n    }\r\n    lux1 = ((float)c0 - (1.87 * (float)c1)) / cpl;\r\n    lux2 = ((0.63 * (float)c0) - (float)c1) / cpl;\r\n    cpl = lux1 >= lux2 ? lux1 : lux2; //max(lux1, lux2);\r\n    *lux = ((cpl >= 0.0) ? cpl : 0.0); //max(cpl, 0.0);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSGain                                                           */\r\n/* AGAIN = 0     ALS Gain value = 1 * gain                                      */\r\n/* AGAIN = 1     ALS Gain value = 8 * gain                                      */\r\n/* AGAIN = 2     ALS Gain value = 16 * gain                                     */\r\n/* AGAIN = 3     ALS Gain value = 120 * gain                                    */\r\n/* AGL = 0       AGAIN = 0 or 1 or 2 or 3     -> scaling by 1                   */\r\n/* AGL = 1       AGAIN = 0 or 1               -> scaling by 0.16                */\r\n/* Do not use AGL = 1 with AGAIN = 2 or 3                                       */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    if ((AGAIN > 1) && (AGL)){\r\n        return TSL2572_sensor_wrong_parameter;\r\n    }\r\n\r\n    wBuf[0] = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = AGAIN & TSL2572_AGAIN_MASK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AGL bit */\r\n    if (AGL){\r\n        wBuf[1] = rBuf | TSL2572_AGL_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AGL_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if ((AGAIN & TSL2572_AGAIN_MASK) == 0) gain_val = 1;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 1) gain_val = 8;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 2) gain_val = 16;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 3) gain_val = 120;\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSTime                                                           */\r\n/* set ALS Time = the ALS ADC integration time                                  */\r\n/* ATIME = 0xFF     ALS integration cycles = 1,   time = 2.73ms                 */\r\n/* ATIME = 0xF6     ALS integration cycles = 10,  time = 27.3ms                 */\r\n/* ATIME = 0xDB     ALS integration cycles = 37,  time = 101ms                  */\r\n/* ATIME = 0xC0     ALS integration cycles = 64,  time = 175ms                  */\r\n/* ATIME = 0x00     ALS integration cycles = 256, time = 699ms                  */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = ATIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* set ALS interrupt threshold low and threshold high                             */\r\n/* the thresholds refer to C0 photo_diode only                                     */\r\n/* (C1 is not used to trigger interrupts)                                        */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[5];\r\n\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = (uint8_t)(ALS_interrupt_Low_Threshold & 0x00FF);\r\n    wBuf[2] = (uint8_t)((ALS_interrupt_Low_Threshold & 0xFF00) >> 8);\r\n    wBuf[3] = (uint8_t)(ALS_interrupt_High_Threshold & 0x00FF);\r\n    wBuf[4] = (uint8_t)((ALS_interrupt_High_Threshold & 0xFF00) >> 8);\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* get ALS interrupt threshold low and threshold high                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    *ALS_interrupt_Low_Threshold = (uint16_t) (rBuf[1]<<8 | rBuf[0]);\r\n    *ALS_interrupt_High_Threshold = (uint16_t) (rBuf[3]<<8 | rBuf[2]);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSPersistence                                                    */\r\n/* set ALS interrupt persistence filter                                            */\r\n/* APERS = 0     every ALS cycle generates an interrupt                           */\r\n/* APERS = 1     1 value outside of threshold range generates an interrupt        */\r\n/* APERS = 2     2 consecutive values out of range generates an interrupt         */\r\n/* APERS = 3     3 consecutive values out of range generates an interrupt         */\r\n/* APERS = 4     5 consecutive values out of range generates an interrupt         */\r\n/* APERS = 5     10 consecutive values out of range generates an interrupt         */\r\n/* APERS = 6     15 consecutive values out of range generates an interrupt         */\r\n/* APERS = 7     20 consecutive values out of range generates an interrupt         */\r\n/* APERS = 8     25 consecutive values out of range generates an interrupt         */\r\n/* APERS = 9     30 consecutive values out of range generates an interrupt         */\r\n/* APERS = 10    35 consecutive values out of range generates an interrupt         */\r\n/* APERS = 11    40 consecutive values out of range generates an interrupt         */\r\n/* APERS = 12    45 consecutive values out of range generates an interrupt         */\r\n/* APERS = 13    50 consecutive values out of range generates an interrupt         */\r\n/* APERS = 14    55 consecutive values out of range generates an interrupt         */\r\n/* APERS = 15    60 consecutive values out of range generates an interrupt         */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = APERS & TSL2572_APERS_MSK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetWaitTime                                                             */\r\n/* WTIME = 0xFF     Wait time = 2.73ms (WLONG = 0), 0.033s (WLONG = 1)           */\r\n/* WTIME = 0xB6     Wait time = 202ms (WLONG = 0), 2.4s (WLONG = 1)               */\r\n/* WTIME = 0x00     Wait time = 699ms (WLONG = 0), 8.4s (WLONG = 1)               */\r\n/* The Wait time register should be configured before TSL2572_Enable_ALS(true)    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    wBuf[0] = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = WTIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WLONG bit */\r\n    if (WLONG){\r\n        wBuf[1] = rBuf | TSL2572_WLONG_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WLONG_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AIEN bit */\r\n    if (AIEN){\r\n        wBuf[1] = rBuf | TSL2572_AIEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AIEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_ClearALSInterrupt(void){\r\n    uint8_t wBuf;\r\n\r\n    wBuf = TSL2572_COMMAND_MSK | TSL2572_TYPE_SPL_FN_MSK | TSL2572_ADD_ALS_INT_CLR_MSK;\r\n    if (sTSL2572_Func.I2C_Write(&wBuf, sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_ALS                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_ALS(bool AEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AEN bit */\r\n    if (AEN){\r\n        wBuf[1] = rBuf | TSL2572_AEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_Wait                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_Wait(bool WEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WEN bit */\r\n    if (WEN){\r\n        wBuf[1] = rBuf | TSL2572_WEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Power_ON                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Power_ON(bool PON){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask PON bit */\r\n    if (PON){\r\n        wBuf[1] = rBuf | TSL2572_PON_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_PON_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAllRegisters                                                        */\r\n/* RegData contains 16 * uint8_t                                                */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read ENABLE register */\r\n    wBuf = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ATIME register */\r\n    wBuf = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read WTIME register */\r\n    wBuf = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTL register */\r\n    wBuf = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTH register */\r\n    wBuf = TSL2572_REG_AILTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTL register */\r\n    wBuf = TSL2572_REG_AIHTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTH register */\r\n    wBuf = TSL2572_REG_AIHTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read PERS register */\r\n    wBuf = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONFIG register */\r\n    wBuf = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONTROL register */\r\n    wBuf = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ID register */\r\n    wBuf = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read STATUS register */\r\n    wBuf = TSL2572_REG_STATUS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATA register */\r\n    wBuf = TSL2572_REG_C1DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATAH register */\r\n    wBuf = TSL2572_REG_C1DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadCH0                                                                 */\r\n/* RegData contains 2 * uint8_t                                                    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n"
              }
            }
          }
        },
        "mpl3115": {
          "libName": "mpl3115",
          "description": "NXP MPL3115 Pressure and Altitude Sensor",
          "type": "Pressure + Altitute Sensor",
          "icon": "",
          "manufacturer": "NXP Semiconductors",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "MPL3115Pressure",
              "type": "EmbeddedMPL3115",
              "icon": "EmbeddedPressure.svg",
              "defaultAbility": "readPressure",
              "defaultTrigger": "pressureRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_MPL3115_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.MPLsettings.mode = MPL_MODE_PRESSURE;\n\tconfig.MPLsettings.oversample = MPL_OS_0;\t\t\t// oversampling = 1\n\tconfig.MPLsettings.autoAcquisitionTime = MPL_ST_0;\t// Auto acquisition time = 1s\n\tconfig.MPLsettings.pressureOffset = ATMO_PROPERTY(undefined, pressureOffset);\t// Offset pressure correction = 4*-128 = -512Pa (8 bits signed integer)\n\tconfig.MPLsettings.altitudeOffset = ATMO_PROPERTY(undefined, altitudeOffset);\t// Offset altitude correction = 128m (signed 8 bits integer)\n\tconfig.MPLsettings.tempOffset = ATMO_PROPERTY(undefined, tempOffset);\t\t\t// Offset temperature correction -8C (0.0625C/LSB)\n\tconfig.MPLsettings.fifoMode = FIFO_DISABLED;\t\t// FIFO mode disabled\n\tconfig.MPLsettings.fifoWatermark = 5;\t\t\t\t// 6 bits to set the number of FIFO samples required to trigger a watermark interrupt.\n\tconfig.MPLsettings.fifoINTpin = FIFO_INT1;\t\t\t// set pin INT1 as output for FIFO interrupt\n\n\treturn ( ATMO_MPL3115_Init(&config) == ATMO_MPL3115_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_MPL3115_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAltitude",
                  "triggers": [
                    "altitudeRead"
                  ],
                  "code": "    uint32_t altitudeMeters;\n    if(ATMO_MPL3115_GetAltitude(&altitudeMeters) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)altitudeMeters);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressure",
                  "triggers": [
                    "pressureRead"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)pressurePa);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressureKpa",
                  "triggers": [
                    "pressureReadKpa"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)(pressurePa/1000));\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x60"
                },
                {
                  "name": "pressureOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "altitudeOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "tempOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedMPL3115": "MPL3115 Pressure",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readAltitude": "Read Altitude",
                  "readPressure": "Read Pressure",
                  "readPressureKpa": "Read Pressure (kPa)",
                  "pressureRead": "Pressure Read",
                  "altitudeRead": "Altitude Read",
                  "pressureReadKpa": "Pressure Read (kPa)",
                  "pressureOffset": "Pressure Offset",
                  "altitudeOffset": "Altitude Offset",
                  "tempOffset": "Temperature Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "mpl3115.h": "#ifndef __ATMO_MPL3115_H_\n#define __ATMO_MPL3115_H_\n\n#include \"mpl3115_internal.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_MPL3115_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_MPL3115_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_MPL3115_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_MPL3115_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_MPL3115_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_MPL3115_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n\tsettingsMPL_t MPLsettings;\n} ATMO_MPL3115_Config_t;\n\n\n/**\n * Initialize MPL3115 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config);\n\n/**\n * Enable/Disable MPL3115 Driver\n *\n * @param[in] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of MPL3115 driver\n *\n * @param[out] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config);\n\n/**\n * Get Barometeric Pressure in Pascals\n * \n * @param[out] pressurePascals\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperature\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Altitude in meters\n * \n * @param[out] altitudeMeters\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters);\n\n#endif\n",
                "mpl3115_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the header file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#ifndef MPL3115_H_\n#define MPL3115_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*!\n * @addtogroup mpl3115 MPL3115 atmospheric pressure sensor\n * This module provides the API to operate the MPL3115 atmospheric pressure sensor through an I2C interface.\n *\n * The MPL3115A2 is a compact, piezoresistive, absolute pressure sensor with an I2C\n * digital interface. MPL3115A2 has a wide operating range of 20 kPa to 110 kPa, a range\n * that covers all surface elevations on earth. The MEMS is temperature compensated\n * utilizing an on-chip temperature sensor. The pressure and temperature data is fed into\n * a high resolution ADC to provide fully compensated and digitized outputs for pressure\n * in Pascals and temperature in C.\n *\n * Usage\n *-----------------------------------------------------------------------------------------------------------\n *\n * Initialization:\n * @code\n *\n *  #include \"mpl3115.h\"\n *\n *  mpl3115_IoFunc_t MPL3115_sensor;\n *  MPL3115_sensor.I2C_Read = App_I2C1_Read;\n *  MPL3115_sensor.I2C_Write = App_I2C1_Write;\n *  MPL3115_sensor.WaitMsec = App_WaitMsec;\n *\n *  MPL3115_Init_Driver(&MPL3115_sensor);\n *  MPL3115_Init_Hw();\n * @endcode\n *\n * Basic Operation:\n * @code\n *\n *  int32_t data;\n *\n *  if (MPL_ReadRawData (MPL_MODE_PRESSURE, &data) == 0)\n *  {\n *        data /= 400; // in HPa (LSB = 0.25Pa)\n *  }\n *\n * @endcode\n *\n * @{\n */\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _mpl3115_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);     /*!< Function pointer to I2C Read function. */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);                                         /*!< Function pointer to I2C Write function. */\n    void      (*WaitMsec)(uint32_t millisec);                                                                                   /*!< Function pointer to waitMsec function  */\n} mpl3115_IoFunc_t, *pmpl3115_IoFunc_t;\n\ntypedef int16_t mE_t;\n\n/*! @brief Status return codes. */\ntypedef enum\n{\n    MPL_SUCCESS,            /*!< Function ran successfully. */\n    MPL_ERROR,              /*!< Error in running function. */\n    MPL_PROTOCOL_ERROR,     /*!< Protocol error has occurred. */\n    MPL_INIT_ERROR,         /*!< Initialization error has occurred. */\n    MPL_TIMEOUT,            /*!< MPL function has timed out */\n    MPL_NOT_SUPPORTED       /*!< Not Supported */\n} mpl_status_t;\n\n/*! @brief Oversampling factor */\ntypedef enum {\n    MPL_OS_0,               /*!< Oversample Ratio = 1    */\n    MPL_OS_1,               /*!< Oversample Ratio = 2    */\n    MPL_OS_2,               /*!< Oversample Ratio = 4    */\n    MPL_OS_3,               /*!< Oversample Ratio = 8    */\n    MPL_OS_4,               /*!< Oversample Ratio = 16   */\n    MPL_OS_5,               /*!< Oversample Ratio = 32   */\n    MPL_OS_6,               /*!< Oversample Ratio = 64   */\n    MPL_OS_7                /*!< Oversample Ratio = 128  */\n} overSampleMPL_t;\n\n/*! @brief Auto acquisition time step : power(2; MPL_ST_X) */\ntypedef enum {\n    MPL_ST_0,               /*!< Auto acquistion time step = 1 second       */\n    MPL_ST_1,               /*!< Auto acquistion time step = 2 seconds      */\n    MPL_ST_2,               /*!< Auto acquistion time step = 4 seconds      */\n    MPL_ST_3,               /*!< Auto acquistion time step = 8 seconds      */\n    MPL_ST_4,               /*!< Auto acquistion time step = 16 seconds     */\n    MPL_ST_5,               /*!< Auto acquistion time step = 32 seconds     */\n    MPL_ST_6,               /*!< Auto acquistion time step = 64 seconds     */\n    MPL_ST_7,               /*!< Auto acquistion time step = 128 seconds    */\n    MPL_ST_8,               /*!< Auto acquistion time step = 256 seconds    */\n    MPL_ST_9,               /*!< Auto acquistion time step = 512 seconds    */\n    MPL_ST_10,              /*!< Auto acquistion time step = 1024 seconds   */\n    MPL_ST_11,              /*!< Auto acquistion time step = 2048 seconds   */\n    MPL_ST_12,              /*!< Auto acquistion time step = 4096 seconds   */\n    MPL_ST_13,              /*!< Auto acquistion time step = 8192 seconds   */\n    MPL_ST_14,              /*!< Auto acquistion time step = 16384 seconds  */\n    MPL_ST_15               /*!< Auto acquistion time step = 32768 seconds  */\n} autoAcquisitionTime_t;\n\n/*! @brief Device Mode */\ntypedef enum {\n    MPL_MODE_PRESSURE    = 0,   /*!< Device is in barometer mode. It reports an absolute pressure.  */\n    MPL_MODE_ALTITUDE    = 1,   /*!< Device is in altimeter mode. The pressure data is converted to equivalent altitude based on US standard atmosphere */\n    MPL_MODE_TEMPERATURE = 2,   /*!< This mode provides temperature from a high resolution temperature sensor. */\n    MPL_MODE_CURRENT     = 0xFF\n} modeMPL_t;\n\n/*! @brief Fifo Mode */\ntypedef enum {\n    FIFO_DISABLED,        /*!< FIFO is disabled (reset value) */\n    FIFO_CIRCULAR,        /*!< FIFO contains the most recent samples when overflowed (circular buffer). Oldest sample is discarded to be replaced by new sample*/\n    FIFO_STOP_OVERFLOW    /*!< FIFO stops accepting new samples when overflowed */\n} modeFIFO_t;\n\n/*! @brief Pin to route FIFO interrupt */\ntypedef enum {\n    FIFO_INT1    = 1,   /*!< FIFO Interrupt routed to INT1 pin */\n    FIFO_INT2    = 0    /*!< FIFO Interrupt routed to INT2 pin */\n} pinINT_t;\n\n/* structure that contains MPL settings */\ntypedef struct {\n    modeMPL_t                 mode;                    /*!< device mode, altimeter or barometer */\n    overSampleMPL_t           oversample;              /*!< oversampling ratio */\n    autoAcquisitionTime_t     autoAcquisitionTime;     /*!< Auto acquisition time step */\n    int8_t                    pressureOffset;          /*!< Offset pressure correction (signed: 4 Pa/LSB) */\n    int8_t                    altitudeOffset;          /*!< Offset altitude correction (signed: 1m/LSB) */\n    int8_t                    tempOffset;              /*!< Offset temperature correction -8C (signed: 0.0625C/LSB) */\n    modeFIFO_t                fifoMode;                /*!< FIFO mode */\n    uint8_t                   fifoWatermark;           /*!< These (6) bits set the number of FIFO samples required to trigger a watermark interrupt. */\n    pinINT_t                  fifoINTpin;              /*!< Pin to route FIFO interrupt */\n} settingsMPL_t;\n\n/* MPL3115 I2C slave address */\n#define MPL3115_I2C_SLAVE_ADDRESS                (uint8_t)0x60\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize MPL3115 driver.\n * @note  Wrap the low level functions (I2C write, I2C read, WaitMsec).\n * @param pIoFunc  Pointer to a structure with external functions\n */\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc);\n\n/*!\n * @brief De-initialize MPL3115 driver.\n *\n */\nvoid MPL3115_Deinit_Driver();\n\n/*!\n * @brief Initialize MPL3115 hardware.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings);\n\n/*!\n * @brief Soft reset.\n * @note\n * The reset mechanism can be enabled in standby and active mode.\\n\n * When this bit is enabled, the reset mechanism resets all functional block\n * registers and loads the respective internal registers with default values\n * If the system was already in standby mode, the reboot process will\\n\n * immediately begin; else if the system was in active mode, the boot mechanism\n * will automatically transition the system from active mode to standby mode,\n * and only then can the reboot process begin.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SoftReset();\n\n/*!\n * @brief Toggle the OST bit.\n * @note Clears then sets the OST bit which causes the sensor to immediately\n * take another reading, necessary to sample faster than 1Hz.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ToggleOneShot();\n\n/*!\n * @brief Read the chip ID.\n *\n * @param sensorID Chip ID value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetID(uint8_t* sensorID);\n\n/*!\n * @brief Set the device mode (barometer or altimeter).\n *\n * @param mode 1 - barometer\n *             0 - altimeter\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetMode (modeMPL_t mode);\n\n/*!\n * @brief Put the sensor in stand-by mode.\n * @note It is needed to modify major control registers.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GotoStandby ();\n\n/*!\n * @brief Put the sensor in active mode.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetActive();\n\n/*!\n * @brief Set the over-sample rate.\n * @note\n * Datasheet calls for 128, but you can set it from 1 to 128 samples.\n * The higher the oversample rate, the greater the time between data samples.\n *\n * @param sampleRate Over-sample rate value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate);\n\n/*!\n * @brief Set the auto-acquisition time step.\n * @note\n * Reset value = 0.\\n\n * Step is power(2; sampleTime).\n *\n * @param sampleTime Sample time value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetAutoAcquisitionTime (uint8_t sampleTime);\n\n/*!\n * @brief Enable pressure and temperature measurement event flags.\n * @note This is recommended in datasheet during setup.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_EnableEventFlags();\n\n/*!\n * @brief Set the offset pressure correction.\n * @note\n * Pressure user accessible offset trim value number.\\n\n * The user offset registers may be adjusted to enhance accuracy and optimize\n * the system performance.\\n\n * Range is from 512 to +508 Pa, 4 Pa/LSB.\n *\n * @param pressOffset Pressure offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset);\n\n/*!\n * @brief Set the offset altitude correction.\n * @note\n * Altitude user accessible offset trim value number.\\n\n * The user offset register provides user adjustment to the vertical height of\n * the altitude output.\\n\n * The range of values are from 128 to +127 meters.\n *\n * @param altitudeOffset Altitude offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset);\n\n/*!\n * @brief Set the offset temperature correction.\n * @note\n * Temperature user accessible offset trim value number.\\n\n * The range of values is from 8 to +7.9375 C, 0.0625 C/LSB.\n *\n * @param temperatureOffset Temperature offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset);\n\n/*!\n * @brief Set the FIFO mode\n * @note\n * It can be configured in either circular buffer or in overflow mode.\\n\n * In circular buffer mode, a watermark can be set to trigger a flag event.\n * Exceeding the watermark, count does not stop the FIFO from accepting new\n * data, the oldest data is overwritten.\n *\n * @param fMode FIFO mode\n * @param fWmrk Watermark\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk);\n\n/*!\n * @brief Setup the FIFO interrupt and route it to pin INT1 or INT2\n *\n * @param pinINT Interrupt pin selection (INT1 or INT2)\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT);\n\n/*!\n * @brief Disable the FIFO interrupt\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_DisableFifoInterrupt();\n\n/*!\n * @brief Read the FIFO status register.\n *\n * @param fifoStatus Pointer to FIFO status\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus);\n\n/*!\n * @brief Read sensor raw data\n *\n * @param  mode Sensor mode (pressure, altitude...)\n * @param  sensorData Pointer to the sensor data\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData);\n\n/*!\n * @brief Read all the chip registers\n *\n * @param  sensorReg Pointer to the register dump\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Dump(uint8_t* sensorReg);\n\n/*! @}*/\n\n#endif /* MPL3115_H_ */\n"
              },
              "objects": {
                "mpl3115.c": "#include \"mpl3115.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_MPL3115_Config_t config;\n    bool configured;\n} ATMO_MPL3115_Priv_Config;\n\nstatic ATMO_MPL3115_Priv_Config _ATMO_MPL3115_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_MPL3115_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool mpl3115Enabled = true;\n\nstatic uint8_t ATMO_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\n\nstatic uint8_t ATMO_MPL3115_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_MPL3115_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_MPL3115_config.configured = false;\n    }\n\n    mpl3115_IoFunc_t io;\n    io.I2C_Read = ATMO_I2CRead_Simple;\n    io.I2C_Write = ATMO_MPL3115_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    MPL3115_Init_Driver(&io);\n    MPL3115_Init_Hw(&config->MPLsettings);\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled)\n{\n    mpl3115Enabled = enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled)\n{\n    *enabled = mpl3115Enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_MPL3115_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy( &_ATMO_MPL3115_config.config, config, sizeof(ATMO_MPL3115_Config_t) );\n    _ATMO_MPL3115_config.configured = true;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !_ATMO_MPL3115_config.configured )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_MPL3115_config.config, sizeof(ATMO_MPL3115_Config_t));\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)pressurePascals) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *pressurePascals = (*pressurePascals) / 4;\n\n    return ATMO_MPL3115_Status_Success;\n        \n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_TEMPERATURE, (int32_t *)temperatureCelsius) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *temperatureCelsius = (*temperatureCelsius) / 16;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n    \n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)altitudeMeters) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *altitudeMeters = (*altitudeMeters) / 16;\n\n    return ATMO_MPL3115_Status_Success; \n}\n\n\n\n\n",
                "mpl3115_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the source file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#include \"mpl3115_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/* unshifted 7-bit I2C address */\n#define MPL_I2C_ADDRESS  (0x60)\n\n#define REG_STATUS      (0x00)\n#define OUT_P_MSB       (0x01)\n#define OUT_P_CSB       (0x02)\n#define OUT_P_LSB       (0x03)\n#define OUT_T_MSB       (0x04)\n#define OUT_T_LSB       (0x05)\n#define DR_STATUS       (0x06)\n#define OUT_P_DELTA_MSB (0x07)\n#define OUT_P_DELTA_CSB (0x08)\n#define OUT_P_DELTA_LSB (0x09)\n#define OUT_T_DELTA_MSB (0x0A)\n#define OUT_T_DELTA_LSB (0x0B)\n#define WHO_AM_I        (0x0C)\n#define F_STATUS        (0x0D)\n#define F_DATA          (0x0E)\n#define F_SETUP         (0x0F)\n#define TIME_DLY        (0x10)\n#define SYSMOD          (0x11)\n#define INT_SOURCE      (0x12)\n#define PT_DATA_CFG     (0x13)\n#define BAR_IN_MSB      (0x14)\n#define BAR_IN_LSB      (0x15)\n#define P_TGT_MSB       (0x16)\n#define P_TGT_LSB       (0x17)\n#define T_TGT           (0x18)\n#define P_WND_MSB       (0x19)\n#define P_WND_LSB       (0x1A)\n#define T_WND           (0x1B)\n#define P_MIN_MSB       (0x1C)\n#define P_MIN_CSB       (0x1D)\n#define P_MIN_LSB       (0x1E)\n#define T_MIN_MSB       (0x1F)\n#define T_MIN_LSB       (0x20)\n#define P_MAX_MSB       (0x21)\n#define P_MAX_CSB       (0x22)\n#define P_MAX_LSB       (0x23)\n#define T_MAX_MSB       (0x24)\n#define T_MAX_LSB       (0x25)\n#define MPL_CTRL_REG1   (0x26)\n#define MPL_CTRL_REG2   (0x27)\n#define MPL_CTRL_REG3   (0x28)\n#define MPL_CTRL_REG4   (0x29)\n#define MPL_CTRL_REG5   (0x2A)\n#define OFF_P           (0x2B)\n#define OFF_T           (0x2C)\n#define OFF_H           (0x2D)\n\n// SHIFTS\n#define MPL_OS_SHIFT    (3)\n\n#define MPL_TDR_SHIFT   (1)\n#define MPL_PDR_SHIFT   (2)\n#define MPL_PTDR_SHIFT  (3)\n\n#define MPL_SBYB_SHIFT  (0)\n#define MPL_OST_SHIFT   (1)\n#define MPL_RST_SHIFT   (2)\n\n#define INT_EN_FIFO_SHIFT   (6)\n#define INT_CFG_FIFO_SHIFT  (6)\n\n// MASKS\n#define MPL_OS_MASK         (0x7 << MPL_OS_SHIFT)\n#define MPL_F_WMRKK_MASK    0xF\n\n/* MPL3115 CTRL_REG1 register */\n#define MPL_RST             (1 << 2)\n#define MPL_OST             (1 << 1)\n#define MPL_SBYB            (1 << 0)\n\n/***********************************************************************************/\n/* variables                                                                       */\n/***********************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic mpl3115_IoFunc_t sIoFunc;\n\n/* variable which denotes the sensor working as altimeter/barometer */\nstatic modeMPL_t selectedMode = MPL_MODE_PRESSURE;\n\nstatic uint16_t\nselectedSampleRate  = 0xA5A5,\nselectedDelay       = 0xA5A5;\n\n/* oversample factor */\nstatic uint16_t overSampleFactors[] = { 1,  2,  4,  8, 16,  32,  64, 128 };\n/* min. time between data samples in [ms] */\nstatic uint16_t overSampleDelays[]  = { 6, 10, 18, 34, 66, 130, 258, 512 };\n\nstatic settingsMPL_t settings;\n\n\n/*****************************************************************************\n * Static functions\n ****************************************************************************/\n\n/*\n * @brief Initialize the internal structures.\n *\n * @param mplSettings Pointer to the internal settings structure\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Init(const settingsMPL_t* mplSettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    memcpy( (void*)&settings, (void*)mplSettings, sizeof(settings) );\n\n    // reset all registers to POR values\n    if (MPL_SoftReset()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set the mode\n    else if (MPL_SetMode(settings.mode)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // set over-sampling\n    else if (MPL_SetOversampleRate(settings.oversample)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // enable the flags\n    else if (MPL_EnableEventFlags()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set auto acquisition time step\n    else if (MPL_SetAutoAcquisitionTime(settings.autoAcquisitionTime)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset pressure correction\n    else if (MPL_SetOffsetPressure(settings.pressureOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset altitude correction\n    else if (MPL_SetOffsetAltitude(settings.altitudeOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset temperature correction\n    else if (MPL_SetOffsetTemperature(settings.tempOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // setup FIFO register mode and event count to trigger interrupt\n    else if (MPL_SetFifoMode(settings.fifoMode, settings.fifoWatermark)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set FIFO interrupt and output pin (INT1 or INT2)\n    else if (MPL_SetFifoInterrupt(settings.fifoINTpin)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // goto active state\n    else if (MPL_SetActive()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    return status;\n}\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc)\n{\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sIoFunc = *pIoFunc;\n    initDriverDone = true;\n}\n\nvoid MPL3115_Deinit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        MPL_GotoStandby(); /* skip error management */\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    if (!initDriverDone) return MPL_INIT_ERROR;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    /* initialize the sensor */\n    status = MPL_Init(MPLsettings);\n    if (status != MPL_SUCCESS) initHwDone = false;\n    return status;\n\n}\n\nmpl_status_t MPL_SoftReset()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1, MPL_RST};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // Reset all registers to POR value\n    if (sIoFunc.I2C_Write(wBuf, 2)!= MPL_SUCCESS) return MPL_ERROR;\n    else\n    {\n        // by the end of the boot process the RST bit should be de-asserted to 0 => need to wait before next operation\n        sIoFunc.WaitMsec(10); // 10ms delay\n        return MPL_SUCCESS;\n    }\n}\n\nmpl_status_t MPL_ToggleOneShot()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear OST bit and write it back\n    wBuf[1] = rBuf & ~(MPL_OST);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read again settings, just to be safe\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set OST bit and write it back\n    wBuf[1] = rBuf | MPL_OST;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetID(uint8_t* sensorID)\n{\n    uint8_t wBuf[1] = {WHO_AM_I};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorID != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, sensorID, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetMode (modeMPL_t mode)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set/clear ALT bit\n    switch (mode)\n    {\n    case MPL_MODE_PRESSURE: {\n        wBuf[1] = rBuf & ~( 1 << 7 ); // Clear ALT bit\n        break;\n    }\n    case MPL_MODE_ALTITUDE: {\n        wBuf[1] = rBuf | ( 1 << 7 ); // Set ALT bit\n        break;\n    }\n    case MPL_MODE_TEMPERATURE: {\n        break;\n    }\n    default:\n        return MPL_NOT_SUPPORTED;\n    }\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n    // update the static variable\n    selectedMode = mode;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GotoStandby()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear SBYB bit for entering stand-by mode\n    wBuf[1] = rBuf & ~MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetActive()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set SBYB bit for entering active mode\n    wBuf[1] = rBuf | MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // rate cannot be larger than 7\n    if (sampleRate > 7) sampleRate = 7;\n\n    selectedSampleRate = overSampleFactors[sampleRate];\n    selectedDelay      = overSampleDelays[sampleRate];\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear out old OS bits\n    wBuf[1] = rBuf & ~MPL_OS_MASK;\n    // mask in new OS bits\n    wBuf[1] |= ( sampleRate << MPL_OS_SHIFT );\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t  MPL_SetAutoAcquisitionTime (uint8_t sampleTime)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG2};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // mask in new ST bits. sampleTime cannot be larger than 15 Giving a range of 1s to 9.1 hours\n    wBuf[1] |= (sampleTime > 15) ? 15 : sampleTime;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_EnableEventFlags()\n{\n    uint8_t wBuf[] = {PT_DATA_CFG, 0x07};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_P, pressOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset)\n{\n    uint8_t wBuf[] = {OFF_H, altitudeOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_T, temperatureOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk)\n{\n    uint8_t wBuf[2] = {F_SETUP};\n    wBuf[1] = (fMode << 6) | (fWmrk & MPL_F_WMRKK_MASK);\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & set INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf | (1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read CTRL5 register & Route interrupt to either INT1 or INT2 pin\n    wBuf[0] = MPL_CTRL_REG5;\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    wBuf[1] = (pinINT == FIFO_INT1) ? rBuf | (1 << INT_CFG_FIFO_SHIFT) : rBuf &~(1 << INT_CFG_FIFO_SHIFT);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_DisableFifoInterrupt ()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & disable INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf & ~(1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus)\n{\n    uint8_t wBuf[1] = {F_STATUS};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(fifoStatus != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, fifoStatus, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData)\n{\n    uint8_t wBuf[2] = {REG_STATUS};\n    uint8_t rBuf[5];\n    uint8_t dataReadyFlag,\n    dataReadyRegAddr,\n    bytesToRead = 0;\n    int16_t counter = 0;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorData != NULL);\n\n    /* set the new working mode, if given one */\n\n    if  (( mode > MPL_MODE_TEMPERATURE ) && ( mode < MPL_MODE_CURRENT )) return MPL_INIT_ERROR;\n    else if (( MPL_MODE_CURRENT != mode ) && ( selectedMode != mode ))\n    {\n        // goto standby\n        if (MPL_GotoStandby()!=MPL_SUCCESS) return MPL_ERROR;\n        // set the mode\n        if (MPL_SetMode(mode)!=MPL_SUCCESS) return MPL_ERROR;\n        // goto active state\n        if (MPL_SetActive()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    /* prepare for reading data */\n\n    switch (selectedMode)\n    {\n    case MPL_MODE_PRESSURE:\n    case MPL_MODE_ALTITUDE: {\n        dataReadyFlag     = 1 << MPL_PDR_SHIFT;\n        dataReadyRegAddr  = OUT_P_MSB;\n        bytesToRead       = 3;\n        break;\n    }\n\n    case MPL_MODE_TEMPERATURE: {\n        dataReadyFlag     = 1 << MPL_TDR_SHIFT;\n        dataReadyRegAddr  = OUT_T_MSB;\n        bytesToRead       = 2;\n        break;\n    }\n\n    default:  {}\n    }\n\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // check PDR/PTR bit; if it's not set, toggle OST\n    if (0 == (rBuf[0] & dataReadyFlag))\n    {\n        // toggle the OST bit, causing the sensor to immediately take another reading\n        if (MPL_ToggleOneShot()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    // wait for PDR/PTR bit, which indicates that we have new data\n    while (1)\n    {\n        if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        if ((0==(rBuf[0] & dataReadyFlag)) & ( ++counter > 5 )) return MPL_TIMEOUT;\n        else break;\n        sIoFunc.WaitMsec(100);  // Wait 100ms\n    }\n\n    /* read sensor data */\n\n    wBuf[0] = dataReadyRegAddr;\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, bytesToRead)!=MPL_SUCCESS) return MPL_ERROR;\n\n    switch ( selectedMode )\n    {\n    // pressure value is a Q18.2 right-aligned number in [Pa]\n    case MPL_MODE_PRESSURE:\n        // altitude value is a Q16.4 right-aligned number in [m]\n    case MPL_MODE_ALTITUDE:     {\n        *sensorData = (int32_t) ((rBuf[0] << 16) | (rBuf[1] << 8) | rBuf[2]) >> 4;\n        break;\n    }\n\n    // temperature value is a Q8.4 right-aligned number in [C]\n    case MPL_MODE_TEMPERATURE:  {\n        *sensorData = (int32_t) (((rBuf[0] << 8) | rBuf[1]) >> 4);\n        break;\n    }\n    default:  {}\n    }\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_Dump(uint8_t *sensorReg)\n{\n    uint8_t wBuf= 0;\n    uint8_t rBuf;\n    uint8_t i;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorReg != NULL);\n\n    // read all registers\n    for (i=0; i<45; i++)\n    {\n        if (sIoFunc.I2C_Read(&wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        *sensorReg = rBuf;\n        wBuf++;\n        sensorReg++;\n    }\n    return MPL_SUCCESS;\n}\n"
              }
            }
          }
        },
        "ens210": {
          "libName": "ens210",
          "description": "AMS ENS210 Humidity and Temperature Sensor",
          "type": "Humidity + Temperature Sensor",
          "icon": "",
          "manufacturer": "AMS",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "ENS210TemperatureHumidity",
              "type": "EmbeddedENS210",
              "icon": "EmbeddedTempHumidity.svg",
              "defaultAbility": "readTemperature",
              "defaultTrigger": "temperatureRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(undefined, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTemperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readHumidity",
                  "triggers": [
                    "humidityRead"
                  ],
                  "code": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x43"
                },
                {
                  "name": "tempCalibrationOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedENS210": "ENS210 Temperature/Humidity Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readTemperature": "Read Temperature(C)",
                  "temperatureRead": "Temperature Read",
                  "readHumidity": "Read Humidity(%rh)",
                  "humidityRead": "Humidity Read",
                  "tempCalibrationOffset": "Temperature Calibration Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ens210.h": "#ifndef _ATMO_ENS210_H_\n#define _ATMO_ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_ENS210_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_ENS210_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_ENS210_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_ENS210_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_ENS210_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_ENS210_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    int16_t tempCalibrationOffset;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n} ATMO_ENS210_Config_t;\n\n/**\n * Initialize ENS210 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config);\n\n/**\n * Enable/Disable ENS210 Driver\n *\n * @param[in] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of ENS210 driver\n *\n * @param[out] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct);\n\n#endif\n",
                "ens210_internal.h": "/*\n *****************************************************************************\n * Copyright by ams AG                                                       *\n * All rights are reserved.                                                  *\n *                                                                           *\n * IMPORTANT - PLEASE READ CAREFULLY BEFORE COPYING, INSTALLING OR USING     *\n * THE SOFTWARE.                                                             *\n *                                                                           *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS       *\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT         *\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS         *\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     *\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT          *\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     *\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     *\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       *\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     *\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      *\n *****************************************************************************\n */\n\n\n#ifndef __ENS210_H_\n#define __ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*! @addtogroup ens210   ENS210 Driver API\n * This module provides the API to operate an ENS210 relative humidity and temperature sensor with I2C interface.\n *\n * Basic steps to operate the sensor are as follows:\n * -# Set Run mode (#ENS210_SensRun_Set)\n * -# Start measurement (#ENS210_SensStart_Set)\n * -# Wait for measurement to complete\n * -# Read measurement (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get)\n *\n * Please refer to ENS210 Reference Driver and Porting Guide for more details on platform porting. In this module, names\n * T and H have been used to refer to temperature and relative humidity respectively to comply with ENS210 datasheet\n * naming convention.\n *\n * Example 1 - Sample application code to measure temperature and relative humidity without error checking\n * -------------------------------------------------------------------------------------------------------\n * @code\n * uint32_t T_Raw, H_Raw;\n * int32_t T_mCelsius, T_mFahrenheit, T_mKelvin, H_Percent;\n *\n * //Set runmode, start measurement, wait, read measurement (for both T and H)\n * ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * ENS210_SensStart_Set(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START);\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n * ENS210_THVal_Get(&T_Raw,&H_Raw);\n *\n * //Convert the raw temperature to milli Kelvin\n * T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n * //Convert the raw temperature to milli Celsius\n * T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n * //Convert the raw temperature to milli Fahrenheit\n * T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n * printf(\"T crc ok = %s\\n\", ENS210_IsCrcOk(T_Raw)  ? \"yes\" : \"no\");\n * printf(\"T valid = %s \\n\", ENS210_IsDataValid(T_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"T = %ld mK %ld mC %ld mF \\n\", T_mKelvin, T_mCelsius, T_mFahrenheit);\n *\n * //Convert the raw relative humidity to milli %\n * H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n * printf(\"H crc ok = %s\\n\", ENS210_IsCrcOk(H_Raw)  ? \"yes\" : \"no\");\n * printf(\"H valid = %s \\n\", ENS210_IsDataValid(H_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"H = %ld m%%\\n\", H_Percent);\n *\n * @endcode\n *\n *\n * Example 2 - Sample application code to measure relative humidity with error checking\n * ------------------------------------------------------------------------------------\n * @code\n * uint32_t H_Raw;\n * int32_t H_Percent;\n * int status;\n * bool i2cOk;\n *\n * i2cOk = true; //Start accumulating I2C transaction errors\n *\n * status = ENS210_SensRun_Set(ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * status = ENS210_SensStart_Set(ENS210_SENSSTART_H_START);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n *\n * status = ENS210_HVal_Get(&H_Raw);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * if( !i2cOk ) {\n *     printf(\"H i2c error\\n\")\n * } else if( !ENS210_IsCrcOk(H_Raw) ) {\n *     printf(\"H crc error\\n\")\n * } else if( !ENS210_IsDataValid(H_Raw) ) {\n *     printf(\"H data invalid\\n\")\n * } else {\n *     //Convert the raw relative humidity to milli %\n *     H_Percent = ENS210_ConvertRawToPercentageH(H_Raw,1000);\n *     //Update the int32_t format specifier (%ld) based on platform word-size\n *     printf(\"H = %ld m%%\\n\", H_Percent);\n * }\n *\n * @endcode\n *\n * @{\n */\n/*****************************************************************************\n * Types/enumerations/variables\n ****************************************************************************/\n\n/*! @brief Status return codes. */\ntypedef enum ens210_status_ {\n    ens210_success = 0,             /*!< Function returned successfully. */\n    ens210_I2C_error = 1,           /*!< I2C Error. */\n    ens210_invalid_ID = 2,          /*!< Invalid ID. */\n    ens210_Tdata_CRC_error = 3,     /*!< CRC error for temperature data. */\n    ens210_Hdata_CRC_error = 4,     /*!< CRC error for humidity data. */\n    ens210_T_invalid_data = 5,      /*!< Temperature Data is invalid. */\n    ens210_H_invalid_data = 6,      /*!< Humidity Data is invalid. */\n    ens210_wrong_parameter = 7,     /*!< Wrong Parameter entered. */\n    ens210_noinit = 8               /*!< ENS210 was not initialized. */\n} ens210_status_t;\n\n/*! @brief Measurement mode of Sensor */\nenum measurement_mode {\n    mode_TH = 0,        /*!< ENS210 set to measure both temperature and humidity. */\n    mode_Tonly = 1,     /*!< ENS210 set to measure temperature only. */\n    mode_Honly = 2      /*!< ENS210 set to measure humidity only. */\n};\n\n/*! ENS210 os-free driver version info */\n#define ENS210_OSFREE_DRIVER_VERSION            2\n\n/*! ENS210 T and H conversion time in milliseconds. Refer to ENS210 data sheet for timing information. */\n#define ENS210_T_H_CONVERSION_TIME_MS           130\n\n/*! ENS210 T conversion time in milliseconds */\n#define ENS210_T_CONVERSION_TIME_MS             110\n\n/*! ENS210 Booting time in milliseconds. */\n#define ENS210_BOOTING_TIME_MS                  10\n\n/*! ENS210 Reset time in milliseconds. */\n#define ENS210_RESET_WAIT_TIME_MS               10\n\n/*! ENS210 I2C slave address */\n#define ENS210_I2C_SLAVE_ADDRESS                (uint8_t)0x43\n\n/*! ENS210 SysCtrl register: Low power enable */\n#define ENS210_SYSCTRL_LOWPOWER_ENABLE          (1 << 0)\n/*! ENS210 SysCtrl register: Low power disable */\n#define ENS210_SYSCTRL_LOWPOWER_DISABLE         (0 << 0)\n/*! ENS210 SysCtrl register: Reset enable */\n#define ENS210_SYSCTRL_RESET_ENABLE             (1 << 7)\n/*! ENS210 SysCtrl register: Reset disable */\n#define ENS210_SYSCTRL_RESET_DISABLE            (0 << 7)\n\n/*! ENS210 SysStat register: Standby or Booting mode */\n#define ENS210_SYSSTAT_MODE_STANDBY             (0 << 0)\n/*! ENS210 SysStat register: Active mode */\n#define ENS210_SYSSTAT_MODE_ACTIVE              (1 << 0)\n\n\n/*! ENS210 SensRun register: temperature single shot mode */\n#define ENS210_SENSRUN_T_MODE_SINGLE_SHOT       (0 << 0)\n/*! ENS210 SensRun register: temperature continuous mode */\n#define ENS210_SENSRUN_T_MODE_CONTINUOUS        (1 << 0)\n/*! ENS210 SensRun register: relative humidity single shot mode */\n#define ENS210_SENSRUN_H_MODE_SINGLE_SHOT       (0 << 1)\n/*! ENS210 SensRun register: relative humidity continuous mode */\n#define ENS210_SENSRUN_H_MODE_CONTINUOUS        (1 << 1)\n\n/*! ENS210  SensStart register: T sensor start */\n#define ENS210_SENSSTART_T_START                (1 << 0)\n/*! ENS210  SensStart register: H sensor start */\n#define ENS210_SENSSTART_H_START                (1 << 1)\n\n/*! ENS210  SensStop register: T sensor stop */\n#define ENS210_SENSSTOP_T_STOP                  (1 << 0)\n/*! ENS210  SensStop register: H sensor stop */\n#define ENS210_SENSSTOP_H_STOP                  (1 << 1)\n\n/*! ENS210  SensStat register: T sensor idle */\n#define ENS210_SENSSTAT_T_STAT_IDLE             (0 << 0)\n/*! ENS210  SensStat register: T sensor active */\n#define ENS210_SENSSTAT_T_STAT_ACTIVE           (1 << 0)\n/*! ENS210  SensStat register: H sensor idle */\n#define ENS210_SENSSTAT_H_STAT_IDLE             (0 << 1)\n/*! ENS210  SensStat register: H sensor active */\n#define ENS210_SENSSTAT_H_STAT_ACTIVE           (1 << 1)\n\n/* wrapper for the I2C write, I2C read and wait functions needed by the sensor driver */\n/* it is expected that the I2C_Read and I2C_Write functions return 0 if the I2C transaction is successful */\ntypedef struct _ens210_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);  /*!< External I2C read function */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);  /*!< External I2C write function */\n    void      (*WaitMsec)(uint32_t millisec); /*!< Wait function in milliseconds */\n} ens210_IoFunc_t, *pens210_IoFunc_t;\n\n/*! @brief    ENS210 ID block structure */\ntypedef struct ENS210_Ids_s\n{\n    uint16_t    partId;             /*!< Part ID */\n    uint8_t     uId[8];             /*!< Unique Identifier 8 bytes */\n} ENS210_Ids_t;\n\n/*! @brief Structure of measurement data. */\ntypedef struct ens210_meas_data_s\n{\n    int32_t T_Celsius;              /*!< Temperature in Celsius */\n    int32_t T_Fahrenheit;           /*!< Temperature in Fahrenheit */\n    int32_t T_Kelvin;               /*!< Temperature in Kelvin */\n    int32_t T_mCelsius;             /*!< Temperature in milliCelsius */\n    int32_t T_mFahrenheit;          /*!< Temperature in milliFahrenheit */\n    int32_t T_mKelvin;              /*!< Temperature in milliKelvin */\n    int32_t H_Percent;              /*!< Relative Humidity to % */\n    int32_t H_mPercent;             /*!< Relative Humidity to milli% */\n} ens210_meas_data_t;\n\n/****************************************************************************\n * Function Prototypes\n ****************************************************************************/\n\n/*!\n * @brief   Initialize ENS210 driver.\n * @param   pIoFunc     :   Pointer to a structure of external functions or values\n */\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc);\n\n/*!\n * @brief   De-initialize ENS210 driver.\n */\nvoid ENS210_Deinit_Driver();\n\n/*!\n * @brief   Initialize ENS210 hardware.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_Init_Hw(void);\n\n/*!\n * @brief   Set ENS210 SysCtrl register; enabling reset and/or low power.\n * @param   sysCtrl     :   Mask composed of  ENS210_SYSCTRL_xxx macros.\n * @return  The return status value (0 for success)\n *  */\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysCtrl register.\n * @param   sysCtrl     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysStat register.\n * @param   sysStat     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat);\n\n/*!\n * @brief   Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\n * @param   sensRun     :   Mask composed of ENS210_SENSRUN_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun);\n\n/*!\n * @brief   Get ENS210 SensRun register.\n * @param   sensRun     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun);\n\n/*!\n * @brief   Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\n * @param   sensStart   :  Mask composed of ENS210_SENSSTART_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart);\n\n/*!\n * @brief   Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\n * @param   sensStop    :   Mask composed of ENS210_SENSSTOP_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop);\n\n/*!\n * @brief   Get ENS210 SensStat register.\n * @param   sensStat    :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat);\n\n/*!\n * @brief   Get ENS210 TVal register; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * Use ENS210_ConvertRawToXXX to convert raw data to standard units.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_TVal_Get(uint32_t *traw);\n\n/*!\n * @brief   Get ENS210 HVal register; raw measurement data as well as CRC and valid indication.\n * @param   hraw         :   Pointer to receive value of register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_HVal_Get(uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 TVal and HVal registers; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of TVal register. Must not be null.\n * @param   hraw         :   Pointer to receive value of HVal register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 Part ID and UID.\n * @param   ids         :   Pointer to receive ids. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If this function returns an error, it is suggested to reset the device to bring it to a known state.\n */\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids);\n\n/*!\n * @brief   Get ENS210 temperature and humidity measurements\n * @param   meas_mode    :   Measurement mode\n * @param   results      :   Pointer to the result structure\n * @return  The return status value (0 for success)\n * @note\n * mode = 0: temperature and humidity\\n\n * mode = 1: temperature only\\n\n * mode = 2: humidity only\n */\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results);\n\n/*!\n * @}\n */\n\n#endif /* __ENS210_H_ */\n\n"
              },
              "objects": {
                "ens210.c": "#include \"ens210.h\"\n#include \"ens210_internal.h\"\n\ntypedef struct {\n    ATMO_ENS210_Config_t config;\n    bool configured;\n} ATMO_ENS210_Priv_Config;\n\nstatic ATMO_ENS210_Priv_Config _ATMO_ENS210_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_ENS210_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool _ATMO_ENS210_Enabled = true;\n\nstatic uint8_t ATMO_ENS210_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t ATMO_ENS210_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_ENS210_SetConfiguration(config);\n    }\n    else\n    {\n        _ATMO_ENS210_config.configured = false;\n    }\n\n    ens210_IoFunc_t io;\n    io.I2C_Read = ATMO_ENS210_I2CRead_Simple;\n    io.I2C_Write = ATMO_ENS210_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    ENS210_Init_Driver(&io);\n    ENS210_Init_Hw();\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled)\n{\n    _ATMO_ENS210_Enabled = enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled)\n{\n    *enabled = _ATMO_ENS210_Enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_ENS210_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n    memcpy( &_ATMO_ENS210_config.config, config, sizeof(ATMO_ENS210_Config_t) );\n    _ATMO_ENS210_config.configured = true;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL || !_ATMO_ENS210_config.configured )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_ENS210_config.config, sizeof(ATMO_ENS210_Config_t));\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = results.T_Celsius + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_Percent;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = (results.T_mCelsius / 1000.0) + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_mPercent / 1000.0;\n\n    return ATMO_ENS210_Status_Success;\n}",
                "ens210_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file\n * This is the source file for the temperature and humidity sensor ENS210 driver.\n */\n\n#include \"ens210_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/*****************************************************************************\n * Private macros and functions\n ****************************************************************************/\n/* Register addresses */\n#define ENS210_REG_PART_ID     0x00\n#define ENS210_REG_UID         0x04\n#define ENS210_REG_SYS_CTRL    0x10\n#define ENS210_REG_SYS_STAT    0x11\n#define ENS210_REG_SENS_RUN    0x21\n#define ENS210_REG_SENS_START  0x22\n#define ENS210_REG_SENS_STOP   0x23\n#define ENS210_REG_SENS_STAT   0x24\n#define ENS210_REG_T_VAL       0x30\n#define ENS210_REG_H_VAL       0x33\n\n/** Mask to extract 16-bit data from raw T and H values */\n#define ENS210_T_H_MASK        0xFFFFU\n\n/** Simplification macro, implementing integer division with simple rounding to closest number\n *  It supports both positive and negative numbers, but ONLY positive divisors */\n#define IDIV(n,d)              ((n)>0 ? ((n)+(d)/2)/(d) : ((n)-(d)/2)/(d))\n\n#define CRC7WIDTH              7     //7 bits CRC has polynomial of 7th order (has 8 terms)\n#define CRC7POLY               0x89  //The 8 coefficients of the polynomial\n#define CRC7IVEC               0x7F  //Initial vector has all 7 bits high\n\n#define DATA7WIDTH             17\n#define DATA7MASK              ((1UL << DATA7WIDTH) - 1)  //0b 1 1111 1111 1111 1111\n#define DATA7MSB               (1UL << (DATA7WIDTH - 1))  //0b 1 0000 0000 0000 0000\n\n/** When the ENS210 is soldered a correction on T needs to be applied (see application note).\n *  Typically the correction is 50mK. Units for raw T is 1/64K. */\n#define ENS210_TRAW_SOLDERCORRECTION  (50*64/1000)\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\n\nstatic ens210_IoFunc_t sENS210_Func;\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\n\n/*****************************************************************************\n * Private functions prototypes\n ****************************************************************************/\n\n/*\n * @brief   Compute the CRC7 results.\n * @param   val   :   the value\n * @return  The CRC7 computed result\n */\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val);\n\n/*\n * @brief   Verify the CRC of the raw temperature or relative humidity.\n * @param   raw         :  Raw temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Success,  False - Failure.\n * @note    This function can be used on raw T as well as raw H data (since they use the same format and CRC).\n */\nstatic bool ENS210_IsCrcOk(uint32_t raw);\n\n/*\n * @brief   Verify data validity of the raw temperature or relative humidity.\n * @param   raw         :  Raw  temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Valid,  False - Invalid.\n */\nstatic bool ENS210_IsDataValid(uint32_t raw);\n\n/*\n * @brief   Converts a raw temperature value into Kelvin.\n *          The output value is in Kelvin multiplied by parameter \"multiplier\".\n * @param   traw        :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier  :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Kelvin.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Celsius.\n *          The output value is in Celsius multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Celsius.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Fahrenheit.\n *          The output value is in Fahrenheit multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted temperature\n * @return  The temperature value in 1/multiplier Fahrenheit.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw relative humidity value into human readable format.\n * @param   hraw         :   The relative humidity value in the raw format (#ENS210_HVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted relative humidity.\n * @return  The converted relative humidity value\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier);\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\n//Compute the CRC-7 of 'val' (which should only have 17 bits)\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val)\n{\n    //Setup polynomial\n    uint32_t pol= CRC7POLY;\n\n    //Align polynomial with data\n    pol = pol << (DATA7WIDTH-CRC7WIDTH-1);\n\n    //Loop variable (indicates which bit to test, start with highest)\n    uint32_t bit = DATA7MSB;\n\n    //Make room for CRC value\n    val = val << CRC7WIDTH;\n    bit = bit << CRC7WIDTH;\n    pol = pol << CRC7WIDTH;\n\n    //Insert initial vector\n    val |= CRC7IVEC;\n\n    //Apply division until all bits done\n    while( bit & (DATA7MASK<<CRC7WIDTH) )\n    {\n        if( bit & val )\n        {\n            val ^= pol;\n        }\n        bit >>= 1;\n        pol >>= 1;\n    }\n    return val;\n}\n\n//Verify the CRC\nstatic bool ENS210_IsCrcOk(uint32_t raw)\n{\n    uint32_t crc, data;\n\n    assert(raw <= 0xffffffUL);\n\n    //Extract 7-bit CRC(Bit-17 to Bit-23)\n    crc =  (raw >> 17) & 0x7F;\n\n    //Get the raw T/H and data valid indication.\n    data =  raw & 0x1ffff;\n\n    return ENS210_ComputeCRC7(data) == crc;\n}\n\n//Check the Data Valid Bit\nstatic bool ENS210_IsDataValid(uint32_t raw)\n{\n    assert(raw <= 0xffffffUL);\n\n    //Bit-16 is data valid bit. It will be set if data is valid\n    return (raw & (1UL << 16)) != 0;\n}\n\n//Convert raw temperature to Kelvin\n//The output value is in Kelvin multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*K\n    //where m is the multiplier, R the raw value and K is temperature in Kelvin.\n    //K=R/64 (since raw has format 10.6).\n    //m*K =  m*R/64\n    return IDIV(t*multiplier, 64);\n}\n\n//Convert raw temperature to Celsius\n//The output value is in Celsius multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*C\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use C=K-273.15 and K=R/64 (since raw has format 10.6).\n    //m*C = m*(K-273.15) = m*K - 27315*m/100 = m*R/64 - 27315*m/100\n\n    return IDIV(t*multiplier, 64) - IDIV(27315L*multiplier, 100);\n}\n\n//Convert raw temperature to Fahrenheit\n//The output value is in Fahrenheit multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*F\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use F=1.8*(K-273.15)+32 and K=R/64 (since raw has format 10.6).\n\n    //m*F = m*(1.8*(K-273.15)+32) = m*(1.8*K-273.15*1.8+32) = 1.8*m*K-459.67*m = 9*m*K/5 - 45967*m/100 = 9*m*R/320 - 45967*m/100\n    return IDIV(9*multiplier*t, 320) - IDIV(45967L*multiplier, 100);\n\n    //The first multiplication stays below 32 bits (tRaw:16, multiplier:11, 9:4)\n    //The second  multiplication stays below 32 bits (multiplier:10, 45967:16)\n}\n\n//Convert raw relative humidity to readable format\n//The output value is in % multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier)\n{\n    int32_t h;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw relative humidity\n    h = hraw & ENS210_T_H_MASK;\n\n    //As raw format is 7.9, to obtain the relative humidity, it must be divided by 2^9\n    return IDIV(h*multiplier, 512);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n// wrap the low level function (I2C write, I2C read, WaitMsec) required by ENS210 driver\n// this function does not initialize the HW\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc){\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sENS210_Func = *pIoFunc;\n    initDriverDone = true;\n}\n\n// De-initialize the driver\nvoid ENS210_Deinit_Driver(){\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\n// Initialize ENS210 hardware\nens210_status_t ENS210_Init_Hw(void)\n{\n    ens210_status_t status = ens210_success;\n\n    if (!initDriverDone) return ens210_noinit;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    //Reset the sensor\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_RESET_ENABLE | ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_status;\n\n    //Wait for ENS210 to complete reset\n    sENS210_Func.WaitMsec(ENS210_RESET_WAIT_TIME_MS);\n\n    //Set the run mode of sensors\n    status = ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n    if (status != ens210_success) goto return_status;\n\n    return_status:\n    if (status != ens210_success) initHwDone = false;\n    return status;\n}\n\n//Set ENS210 SysCtrl register; enabling reset and/or low power\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL, sysCtrl};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sysCtrl & ~(ENS210_SYSCTRL_LOWPOWER_ENABLE | ENS210_SYSCTRL_RESET_ENABLE)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof (wBuf));\n}\n\n//Get ENS210 SysCtrl register\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysCtrl != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysCtrl, sizeof (*sysCtrl));\n}\n\n//Get ENS210 SysStat register.\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysStat, sizeof (*sysStat));\n}\n\n//Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN, sensRun};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensRun & ~(ENS210_SENSRUN_T_MODE_CONTINUOUS | ENS210_SENSRUN_H_MODE_CONTINUOUS)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensRun register\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensRun != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensRun, sizeof *sensRun);\n}\n\n//Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_START, sensStart};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStart & ~(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STOP, sensStop};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStop & ~(ENS210_SENSSTOP_T_STOP | ENS210_SENSSTOP_H_STOP)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensStat register.\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensStat, sizeof *sensStat);\n}\n\n//Get ENS210 TVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_TVal_Get(uint32_t *traw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(traw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n\n    return status;\n}\n\n//Get ENS210 HVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_HVal_Get(uint32_t *hraw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_H_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(hraw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *hraw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n\n    return status;\n}\n\n//Get ENS210 TVal and Hval registers; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw)\n{\n    uint8_t rBuf[6];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert((traw != NULL) && (hraw != NULL));\n\n    // Read 6 bytes starting from ENS210_REG_T_VAL\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n    *hraw = ((uint32_t)rBuf[5]) << 16 | ((uint32_t)rBuf[4]) << 8 | (uint32_t)rBuf[3];\n\n    return status;\n}\n\n// Get ENS210 Part ID and UID.\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids)\n{\n    uint8_t rBuf[12];\n    uint8_t wBuf[] = {ENS210_REG_PART_ID};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(ids != NULL);\n\n    // Special procedure needed to read ID's: put device in high power (see datasheet)\n    // Set the system in Active mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_DISABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Wait for sensor to go to active mode\n    sENS210_Func.WaitMsec(ENS210_BOOTING_TIME_MS);\n\n    // Get the id's\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n    if (status != ens210_success) goto return_error_status;\n\n    // Copy id's (hw gives partid in little-endian format)\n    ids->partId = ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n    memcpy(&ids->uId[0], &rBuf[4], 8);\n\n    // Go back to low power mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Signal success\n    return status;\n\n    return_error_status:\n    // Make an attempt to restore low-power\n    ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    // Return original I2C error\n    return status;\n}\n\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results){\n    ens210_status_t status;\n    uint8_t meas_status;\n    uint32_t T_Raw = 0, H_Raw = 0;\n    uint32_t conversion_time_ms = 0;\n    uint8_t start_meas = 0;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(results != NULL);\n\n    switch (meas_mode){\n    case mode_TH :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START;\n        break;\n    case mode_Tonly :\n        conversion_time_ms = ENS210_T_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START;\n        break;\n    case mode_Honly :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_H_START;\n        break;\n    default :\n        return ens210_wrong_parameter;\n        break;\n    }\n\n    //check that the previous measurement is completed\n    status = ENS210_SensStat_Get(&meas_status);\n    if (status != ens210_success){\n        return status;\n    }\n    if(meas_status != 0){\n        // trying to start a measurement too early!\n        sENS210_Func.WaitMsec(conversion_time_ms);\n    }\n\n    //Start the measurement\n    status = ENS210_SensStart_Set(start_meas);\n    if(status != ens210_success){\n        //Start of measurement failed.\n        return status;\n    }\n\n    // wait for the measurement to be completed\n    sENS210_Func.WaitMsec(conversion_time_ms);\n\n    if (meas_mode == mode_TH){\n        //Get the temperature and humidity raw value\n        status = ENS210_THVal_Get(&T_Raw, &H_Raw);\n    }\n    else if (meas_mode == mode_Tonly){\n        status = ENS210_TVal_Get(&T_Raw);\n    }\n    else if (meas_mode == mode_Honly){\n        status = ENS210_HVal_Get(&H_Raw);\n    }\n    if(status != ens210_success){\n        //Getting T and/or H values failed\n        return status;\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Tonly)){\n        // Verify the temperature raw value\n        if(!ENS210_IsCrcOk(T_Raw))    {\n            return ens210_Tdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(T_Raw)){\n            return ens210_T_invalid_data;\n        }\n        else {\n            //Convert the raw temperature value to Kelvin\n            results->T_Kelvin = ENS210_ConvertRawToKelvin(T_Raw, 1);\n            //Convert the raw temperature value to Celsius\n            results->T_Celsius = ENS210_ConvertRawToCelsius(T_Raw, 1);\n            //Convert the raw temperature value to Fahrenheit\n            results->T_Fahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1);\n            //Convert the raw temperature value to milli Kelvin\n            results->T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n            //Convert the raw temperature value to milli Celsius\n            results->T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n            //Convert the raw temperature value to milli Fahrenheit\n            results->T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n        }\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Honly)){\n        //Verify the relative humidity raw value\n        if(!ENS210_IsCrcOk(H_Raw)){\n            return ens210_Hdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(H_Raw)){\n            return ens210_H_invalid_data;\n        }\n        else {\n            //Convert the raw relative humidity to %\n            results->H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1);\n            //Convert the raw relative humidity to milli%\n            results->H_mPercent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n        }\n    }\n    return ens210_success;\n}\n"
              }
            }
          }
        },
        "ccs811": {
          "libName": "ccs811",
          "manufacturer": "AMS",
          "description": "Digital Gas Sensor",
          "type": "Digital Gas Sensor",
          "icon": "",
          "image": "ccs811.jpg",
          "version": "",
          "eelVersion": "3",
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "CCS811AirQuality",
              "type": "EmbeddedCCS811",
              "icon": "EmbeddedAirQuality.svg",
              "defaultAbility": "readTVOC",
              "defaultTrigger": "TVOCRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "code": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(undefined, operatingMode);\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTVOC",
                  "triggers": [
                    "TVOCRead"
                  ],
                  "code": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readCO2",
                  "triggers": [
                    "CO2Read"
                  ],
                  "code": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x5A"
                },
                {
                  "name": "operatingMode",
                  "input": "number",
                  "value": "1"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedCCS811": "CCS811 Air Quality Sensor",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Enable Sensor",
                  "setDisabled": "Disable Sensor",
                  "setEnabledDisabled": "Enable/Disable Sensor",
                  "readTVOC": "Read TVOC (ppb)",
                  "readCO2": "Read CO2 (ppm)",
                  "TVOCRead": "TVOC Read",
                  "CO2Read": "CO2 Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ccs811.h": "#ifndef _ATMO_CCS811_H_\r\n#define _ATMO_CCS811_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\n\r\ntypedef enum {\r\n    ATMO_CCS811_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_CCS811_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_CCS811_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_CCS811_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_CCS811_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_CCS811_Status_t;\r\n\r\ntypedef struct {\r\n\t//Mode 0 = Idle\r\n\t//Mode 1 = read every 1s\r\n\t//Mode 2 = every 10s\r\n\t//Mode 3 = every 60s\r\n\t//Mode 4 = RAW mode\r\n\tuint8_t operatingMode;\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_CCS811_Config_t;\r\n\r\n\r\n/**\r\n * Initialize CCS811 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable CCS811 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of CCS811 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Set environmental data for more accurate readings\r\n *\r\n * @param[in] humidity - Pct from 0.0 to 100.0\r\n * @param[in] temperature - Degrees C\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnvironmentalData(float humidity, float temperature);\r\n\r\n/**\r\n * Get Total Volatile Organic Compounds (TVOC) Reading\r\n *\r\n * @param[out] tvoc - TVOC reading in PPB\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc);\r\n\r\n/**\r\n * Get total CO2 Reading in ppm\r\n *\r\n * @param[out] CO2\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2);\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality);\r\n\r\n\r\n#endif\r\n",
                "ccs811_internal.h": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*!\r\n * @file\r\n * This is the header file for the air quality sensor CCS811 driver.\r\n */\r\n\r\n#ifndef CCS811_H_\r\n#define CCS811_H_\r\n\r\n/*!\r\n * @addtogroup ccs811 CCS811 air quality sensor\r\n * This module provides the API to control and monitor the CCS811 air quality sensor through an I2C interface.\r\n *\r\n * The basic steps to operate the CCS811 are as follows:\r\n * -# Initialize the driver with callback functions (#CCS811_Init_Driver)\r\n * -# Initialize the hardware (#CCS811_Init_Hw)\r\n * -# Check data availability (#CCS811_dataAvailable)\r\n * -# Trigger all data acquisition (#CCS811_readAlgorithmResults)\r\n * -# Read the relevant data (for example #CCS811_getCO2)\r\n * -# If the CCS811 is not needed anymore, de-initialize the driver (#CCS811_Deinit_Driver). The CCS811 will\r\n * be switched off. It allows to eventually release shared resources.\r\n *\r\n * Example - Sample application code to set CCS811 without error management\r\n * ------------------------------------------------------------------------\r\n * @code\r\n * \\#include \"CCS811.h\"\r\n *\r\n * CCS811_fct_t ccs811_fct;\r\n * uint8_t ready;\r\n * uint16_t uCO2;\r\n *\r\n * ccs811_fct.connect_hw = Ccs811_Connect;       // callback function to activate CCS811 hardware resource\r\n * ccs811_fct.disconnect_hw = Ccs811_Disconnect; // callback function to deactivate CCS811 hardware resource\r\n * ccs811_fct.I2C_Read = I2c_Read;               // callback function for I2C read\r\n * ccs811_fct.I2C_Write = I2c_Write;             // callback function for I2C write\r\n * ccs811_fct.WaitMsec = WaitMs;                 // wait callback function (in ms)\r\n *\r\n * CCS811_Init_Driver(&ccs811_fct);\r\n * CCS811_Init_Hw();\r\n * // check new data availability\r\n * CCS811_dataAvailable(&ready);\r\n * if (ready == 1) {\r\n *     CCS811_readAlgorithmResults();\r\n *     uCO2 = CCS811_getCO2();\r\n *     printf(\"The current CO2 value is: %d\\n\", uCO2);\r\n * }\r\n * [..]\r\n * // if the CCS811 is not needed anymore, the driver can be de-initialized\r\n * printf(\"Deinitialize CCS811 (it will be turned off)\\n\");\r\n * CCS811_Deinit_Driver();\r\n *\r\n * @endcode\r\n * @{\r\n */\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include <stdbool.h>\r\n\r\n#define CCS811_I2C_ADDRESS              0x5A\r\n\r\n/* Register addresses */\r\n#define CCS811_STATUS                   0x00\r\n#define CCS811_MEAS_MODE                0x01\r\n#define CCS811_ALG_RESULT_DATA          0x02\r\n#define CCS811_RAW_DATA                 0x03\r\n#define CCS811_ENV_DATA                 0x05\r\n#define CCS811_NTC                      0x06\r\n#define CCS811_THRESHOLDS               0x10\r\n#define CCS811_BASELINE                 0x11\r\n#define CCS811_HW_ID                    0x20\r\n#define CCS811_HW_VERSION               0x21\r\n#define CCS811_FW_BOOT_VERSION          0x23\r\n#define CCS811_FW_APP_VERSION           0x24\r\n#define CCS811_ERROR_ID                 0xE0\r\n#define CCS811_APP_START                0xF4\r\n#define CCS811_SW_RESET                 0xFF\r\n#define CCS811_INTERRUPT_DRIVEN         0x8\r\n#define CCS811_THRESHOLDS_ENABLED       0x4\r\n\r\n/*! @brief Status return codes. */\r\ntypedef enum _CCS811_status\r\n{\r\n    CCS811_SUCCESS,        /*!< Success */\r\n    CCS811_ID_ERROR,       /*!< Bad hardware identifier */\r\n    CCS811_I2C_ERROR,      /*!< I2C read/write error */\r\n    CCS811_INTERNAL_ERROR, /*!< Internal hardware error */\r\n    CCS811_NOINIT_ERROR,   /*!< Hardware or driver not initialized */\r\n    CCS811_GENERIC_ERROR   /*!< Generic error (settings not allowed) */\r\n} CCS811_status;\r\n\r\n/*! @brief Structure of external functions or values. */\r\ntypedef struct _CCS811_fct_t\r\n{\r\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize); /*!< External I2C read function */\r\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize); /*!< External I2C write function */\r\n    void (*WaitMsec)(uint32_t tms); /*!< Wait function in milliseconds */\r\n} CCS811_fct_t, *ptCCS811_fct_t;\r\n\r\n/*!\r\n * @brief Initialize CCS811 driver.\r\n *\r\n * @param FCT Pointer to a structure of external functions or values\r\n */\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT);\r\n\r\n/*!\r\n * @brief De-initialize CCS811 driver.\r\n *\r\n */\r\nvoid CCS811_Deinit_Driver();\r\n\r\n/*!\r\n * @brief Initialize CCS811 hardware.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_Init_Hw(void);\r\n\r\n/*!\r\n * @brief Read algorithm results.\r\n * @note Update the total volatile organic compounds (TVOC) in parts per billion (PPB) and the CO2 value.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readAlgorithmResults(void);\r\n\r\n/*!\r\n * @brief Check if error bit is set.\r\n *\r\n * @param  StatusError Pointer to error status bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError);\r\n\r\n/*!\r\n * @brief Check if data is available.\r\n * @note Based on DATA_READ flag in the status register.\r\n *\r\n * @param  value Pointer to available data bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_dataAvailable(uint8_t* value);\r\n\r\n/*!\r\n * @brief Check if APP_VALID is set.\r\n * @note Based on APP_VALID flag in the status register.\r\n *\r\n * @param  value Pointer to APP_VALID bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_appValid(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the error register value.\r\n * @note Based on ERROR_ID register.\r\n *\r\n * @param  value Pointer to error value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  baseline Pointer to baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline);\r\n\r\n/*!\r\n * @brief Set the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  input Baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setBaseline(uint16_t input);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupts.\r\n * @note It clears/sets the nINT signal.\r\n *\r\n * @param  fct Interrupt mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setInterrupts(uint8_t fct);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupt thresholds.\r\n *\r\n * @param  fct Threshold mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setThresholds(uint8_t fct);\r\n\r\n/*!\r\n * @brief Set the drive mode.\r\n * @note\r\n * Mode 0 = Idle\\n\r\n * Mode 1 = read every 1s\\n\r\n * Mode 2 = every 10s\\n\r\n * Mode 3 = every 60s\\n\r\n * Mode 4 = RAW mode\r\n *\r\n * @param  mode Drive mode\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setDriveMode(uint8_t mode);\r\n\r\n/*!\r\n * @brief Set environmental data.\r\n * @note\r\n * Given a temperature and humidity, use these data for better compensation.\r\n *\r\n * @param  relativeHumidity Relative humidity, value within [0,100]\r\n * @param  temperature Temperature (Celsius), value within [-25,+50]\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature);\r\n\r\n/*!\r\n * @brief Set ref resistance.\r\n *\r\n * @param  input Ref resistance\r\n */\r\nvoid CCS811_setRefResistance(float input);\r\n\r\n/*!\r\n * @brief Read NTC.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readNTC(void);\r\n\r\n/*!\r\n * @brief Get Total Volatile Organic Compound (TVOC) value.\r\n *\r\n * @return TVOC value (0ppb to 1187ppb)\r\n */\r\nuint16_t CCS811_getTVOC(void);\r\n\r\n/*!\r\n * @brief Get the equivalent CO2 value.\r\n *\r\n * @return eCO2 value (400ppm to 8192ppm)\r\n */\r\nuint16_t CCS811_getCO2(void);\r\n\r\n/*!\r\n * @brief Get resistance value.\r\n *\r\n * @return Resistance value\r\n */\r\nfloat CCS811_getResistance(void);\r\n\r\n/*!\r\n * @brief Get temperature value.\r\n *\r\n * @return Temperature value (Celsius)\r\n */\r\nfloat CCS811_getTemperature(void);\r\n\r\n/*! @}*/\r\n\r\n#endif /* CCS811_H_ */\r\n"
              },
              "objects": {
                "ccs811.c": "#include \"ccs811.h\"\r\n#include \"ccs811_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n#define CCS811_TVOC_MAX_PPB (1187)\r\n\r\n\r\ntypedef struct {\r\n    ATMO_CCS811_Config_t config;\r\n    bool configured;\r\n} ATMO_CCS811_Priv_Config;\r\n\r\nstatic ATMO_CCS811_Priv_Config _ATMO_CCS811_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool _ATMO_CCS811_Enabled = true;\r\n\r\nstatic uint8_t ATMO_CCS811_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t ATMO_CCS811_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config)\r\n{\r\n\r\n    CCS811_fct_t io;\r\n    io.I2C_Read = ATMO_CCS811_I2CRead_Simple;\r\n    io.I2C_Write = ATMO_CCS811_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    CCS811_Init_Driver(&io);\r\n\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n        _ATMO_CCS811_config.configured = false;\r\n    }\r\n\r\n    if( CCS811_Init_Hw() != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    // The configuration has to be set before the Init_HW routine is called\r\n    // But the Init_HW routine resets the device\r\n    // So, we need to just set the configuration one more time after this reset\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled)\r\n{\r\n    _ATMO_CCS811_Enabled = enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = _ATMO_CCS811_Enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    memcpy( &_ATMO_CCS811_config.config, config, sizeof(ATMO_CCS811_Config_t) );\r\n    _ATMO_CCS811_config.configured = true;\r\n\r\n    if( CCS811_setDriveMode(config->operatingMode) != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_CCS811_config.configured )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_CCS811_config.config, sizeof(ATMO_CCS811_Config_t));\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*tvoc = CCS811_getTVOC();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*co2 = CCS811_getCO2();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    \r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*airQuality = (CCS811_getTVOC() * 100.0) / CCS811_TVOC_MAX_PPB;\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n",
                "ccs811_internal.c": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*!\r\n * @file\r\n * This is the source file for the air quality sensor CCS811 driver.\r\n */\r\n\r\n#include \"ccs811_internal.h\"\r\n#include <math.h>\r\n#include <stdbool.h>\r\n#include <assert.h>\r\n\r\n/*****************************************************************************\r\n * Variables\r\n ****************************************************************************/\r\nstatic CCS811_fct_t FCT_CCS811;\r\nstatic bool initDriverDone = false;\r\nstatic bool initHwDone = false;\r\n\r\n/* air quality values obtained from the sensor */\r\nstatic float refResistance;\r\nstatic float resistance = 10000;\r\nstatic uint16_t tVOC = 0;\r\nstatic uint16_t CO2 = 0;\r\nstatic uint16_t vrefCounts = 0;\r\nstatic uint16_t ntcCounts = 0;\r\nstatic float temperature = 0;\r\n\r\n/*****************************************************************************\r\n * Static functions\r\n ****************************************************************************/\r\n\r\n/*\r\n * @brief Read a CCS811 register.\r\n *\r\n * @param  Address of the register to read\r\n * @param  Pointer to the read value\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_readRegister(uint8_t offset, uint8_t* outputPointer)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, 1);\r\n}\r\n\r\n/*\r\n * @brief Read several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to read\r\n * @param  Pointer to the read values\r\n * @param  Number of consecutive registers to read\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiReadRegister(uint8_t offset, uint8_t *outputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, length);\r\n}\r\n\r\n/*\r\n * @brief Write to a CCS811 register.\r\n *\r\n * @param  Address of the register to write to\r\n * @param  Value to write\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_writeRegister(uint8_t offset, uint8_t dataToWrite)\r\n{\r\n\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    cmd[1] = dataToWrite;\r\n\r\n    return FCT_CCS811.I2C_Write(cmd, 2);\r\n}\r\n\r\n/*\r\n * @brief Write to several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to write to\r\n * @param  Pointer to the values to be written\r\n * @param  Number of consecutive registers to write to\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiWriteRegister(uint8_t offset, uint8_t *inputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[length+1];\r\n    cmd[0] = offset;\r\n    for( uint32_t i = 0; i < length; i++ ) //This waits > 1ms @ 80MHz clock\r\n    {\r\n        cmd[1+i] = inputPointer[i];\r\n    }\r\n    return FCT_CCS811.I2C_Write(cmd, length+1);\r\n}\r\n\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT)\r\n{\r\n    assert((FCT != NULL) &&\r\n            (FCT->I2C_Read != NULL) &&\r\n            (FCT->I2C_Write != NULL) &&\r\n            (FCT->WaitMsec != NULL));\r\n    FCT_CCS811 = *FCT;\r\n    initDriverDone = true;\r\n}\r\n\r\nvoid CCS811_Deinit_Driver()\r\n{\r\n    /* Deinit driver */\r\n    initDriverDone = false;\r\n    initHwDone = false;\r\n}\r\n\r\nCCS811_status CCS811_Init_Hw(void)\r\n{\r\n    uint8_t data[4] = {0x11,0xE5,0x72,0x8A}; /* reset key */\r\n    uint8_t status;\r\n    uint8_t val = 0;\r\n    CCS811_status error_status = CCS811_SUCCESS;\r\n\r\n    if (!initDriverDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* trick to allow calling internal public functions */\r\n    initHwDone = true;\r\n\r\n    /* check HW ID */\r\n    if (CCS811_readRegister( CCS811_HW_ID,  &val) != 0)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (val != 0x81)\r\n    {\r\n        error_status = CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* reset the device */\r\n    if (CCS811_multiWriteRegister(CCS811_SW_RESET, data, 4)!=0)\r\n    {\r\n        error_status =  CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    FCT_CCS811.WaitMsec(10);\r\n\r\n    if (CCS811_checkForStatusError(&status) == CCS811_I2C_ERROR)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (status == true) return CCS811_INTERNAL_ERROR;\r\n\r\n    error_status = CCS811_appValid(&val);\r\n    if (error_status != CCS811_SUCCESS) goto return_status;\r\n    if (val == 0)\r\n    {\r\n        error_status =  CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* write 0 byte to this register to start app */\r\n    //if (CCS811_writeRegister(CCS811_APP_START, 0)!=0) return CCS811_I2C_ERROR;\r\n    val = CCS811_APP_START;\r\n    if (FCT_CCS811.I2C_Write(&val, 1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* read every second */\r\n    if (CCS811_setDriveMode(1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    return_status:\r\n    if (error_status != CCS811_SUCCESS) initHwDone = false;\r\n    return error_status;\r\n}\r\n\r\nCCS811_status CCS811_readAlgorithmResults(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_ALG_RESULT_DATA, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    /* data ordered: co2MSB, co2LSB, tvocMSB, tvocLSB */\r\n    CO2 = ((uint16_t)data[0] << 8) | data[1];\r\n    tVOC = ((uint16_t)data[2] << 8) | data[3];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(StatusError != NULL);\r\n\r\n    /* read the status bit */\r\n    if (CCS811_readRegister(CCS811_STATUS, StatusError )!=0) return CCS811_I2C_ERROR;\r\n    *StatusError = *StatusError & 1 << 0; // bit ERROR\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_dataAvailable(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 3)>>3; // bit DATA_READY\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_appValid(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 4)>>4; // bit APP_VALID\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    *value=0xFF;\r\n    if (CCS811_readRegister(CCS811_ERROR_ID, value )!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(baseline != NULL);\r\n\r\n    uint8_t data[2];\r\n    if (CCS811_multiReadRegister(CCS811_BASELINE,data, 2)!=0) return CCS811_I2C_ERROR;\r\n\r\n    *baseline = ((uint16_t)data[0] << 8) | data[1];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setBaseline(uint16_t input)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[2];\r\n    data[0] = (input >> 8) & 0x00FF;\r\n    data[1] = input & 0x00FF;\r\n\r\n    if (CCS811_multiWriteRegister(CCS811_BASELINE, data, 2)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setInterrupts(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_INTERRUPT_DRIVEN); /* clear INTERRUPT bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_INTERRUPT_DRIVEN); /* set INTERRUPT bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setThresholds(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_THRESHOLDS_ENABLED); /* clear THRESHOLDS bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_THRESHOLDS_ENABLED); /* set THRESHOLDS bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setDriveMode(uint8_t mode)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    if (mode > 4) mode = 4; /* sanitize input */\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value)!=0) return CCS811_I2C_ERROR;\r\n    value &= ~(0b00000111 << 4); /* clear DRIVE_MODE bits */\r\n    value |= (mode << 4); /* mask in mode */\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* check for invalid temperatures */\r\n    if ((temperature < -25) || (temperature > 50)) return CCS811_GENERIC_ERROR;\r\n\r\n    /* check for invalid humidity */\r\n    if ((relativeHumidity < 0) || (relativeHumidity > 100)) return CCS811_GENERIC_ERROR;\r\n\r\n    uint32_t rH = relativeHumidity * 1000; /* 42.348 becomes 42348 */\r\n    uint32_t temp = temperature * 1000; /* 23.2 becomes 23200 */\r\n\r\n    uint8_t envData[4];\r\n\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;\r\n    envData[1] = 0; /* support only increments of 0.5 so bits 7-0 will always be zero */\r\n    if (((rH % 1000) / 100) > 2 && (((rH % 1000) / 100) < 8))\r\n    {\r\n        envData[0] |= 1; /* set 9th bit of fractional to indicate 0.5% */\r\n    }\r\n\r\n    temp += 25000; /* add the 25C offset */\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;\r\n    envData[3] = 0;\r\n    if (((temp % 1000) / 100) > 2 && (((temp % 1000) / 100) < 8))\r\n    {\r\n        envData[2] |= 1;  /* set 9th bit of fractional to indicate 0.5C */\r\n    }\r\n    if (CCS811_multiWriteRegister(CCS811_ENV_DATA, envData, 4)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nvoid CCS811_setRefResistance(float input)\r\n{\r\n    refResistance = input;\r\n}\r\n\r\nCCS811_status CCS811_readNTC(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_NTC, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    vrefCounts = ((uint16_t)data[0] << 8) | data[1];\r\n    ntcCounts = ((uint16_t)data[2] << 8) | data[3];\r\n    resistance = ((float)ntcCounts * refResistance / (float)vrefCounts);\r\n\r\n    temperature = log((long)resistance);\r\n    temperature = 1 / (0.001129148 + (0.000234125 * temperature) + (0.0000000876741 * temperature * temperature * temperature));\r\n    temperature = temperature - 273.15;  /* convert from Kelvin to Celsius */\r\n\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nuint16_t CCS811_getTVOC(void)\r\n{\r\n    return tVOC;\r\n}\r\n\r\nuint16_t CCS811_getCO2(void)\r\n{\r\n    return CO2;\r\n}\r\n\r\nfloat CCS811_getResistance(void)\r\n{\r\n    return resistance;\r\n}\r\n\r\nfloat CCS811_getTemperature(void)\r\n{\r\n    return temperature;\r\n}\r\n\r\n"
              }
            }
          }
        }
      },
      "static": {
        "header": "",
        "footer": "",
        "functions": {
          "ATMO_Setup": {
            "returnType": "void",
            "code": "\n",
            "arguments": []
          }
        }
      }
    },
    "App View": {
      "type": "app",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {
        "appViewLayouts": {
          "360": {
            "640": true
          },
          "375": {
            "667": true
          },
          "1024": {
            "768": true
          }
        }
      },
      "elements": [
        {
          "name": "AirQualityLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 384,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 384,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 460,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 482,
            "editorY": 700
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LightLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 314,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 314,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 360,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 478,
            "editorY": 533
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "HumidityLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 244,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 244,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 260,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 477,
            "editorY": 232
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "TemperatureLabel",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 174,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 230,
                  "y": 174,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 358,
                  "y": 160,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "No Value",
            "font": "18px Helvetica",
            "color": "white",
            "alignment": "center"
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 469,
            "editorY": 79
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "AppUIImage1",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 299,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 299,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 348,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 741,
            "editorY": 407
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 213,
                  "y": 368,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 213,
                  "y": 368,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 448,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 738,
            "editorY": 306
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage3",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 230,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 230,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 248,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 736,
            "editorY": 92
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppUIImage4",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 160,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 100,
                  "height": 100,
                  "x": 212,
                  "y": 160,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 100,
                  "height": 100,
                  "x": 340,
                  "y": 148,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMzUiIGhlaWdodD0iNDUiIHZpZXdCb3g9IjAgMCAxMzUgNDUiPjxkZWZzPjxzdHlsZT4uYXtmaWxsOiM3Mzg1YmY7fTwvc3R5bGU+PC9kZWZzPjx0aXRsZT5EYXRhc2V0VGV4dEJhY2tncm91bmQ8L3RpdGxlPjxyZWN0IGNsYXNzPSJhIiB3aWR0aD0iMTM1IiBoZWlnaHQ9IjQ1Ii8+PC9zdmc+",
            "scaling": "none",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 737,
            "editorY": 6
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "LightColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 290,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 290,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 320,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDk8L3RpdGxlPjxjaXJjbGUgY3g9IjU1IiBjeT0iNTIuNSIgcj0iMzUuNzE0IiBzdHlsZT0iZmlsbDojNzM4NWJmIi8+PHBhdGggZD0iTTU1LDEwMi41YTUwLDUwLDAsMSwxLDUwLTUwQTUwLjA1Nyw1MC4wNTcsMCwwLDEsNTUsMTAyLjVaTTU1LDQuMjg2QTQ4LjIxNCw0OC4yMTQsMCwxLDAsMTAzLjIxNCw1Mi41LDQ4LjI2OCw0OC4yNjgsMCwwLDAsNTUsNC4yODZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTU1LDQ0YTguNSw4LjUsMCwxLDEtOC41LDguNUE4LjUxMiw4LjUxMiwwLDAsMSw1NSw0NG0wLTIuMTI2QTEwLjYyOSwxMC42MjksMCwxLDAsNjUuNjI5LDUyLjUsMTAuNjI5LDEwLjYyOSwwLDAsMCw1NSw0MS44NzFaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTU1LDM4LjY4MmExLjA2MywxLjA2MywwLDAsMS0xLjA2My0xLjA2M1YzMS4yNDFhMS4wNjMsMS4wNjMsMCwwLDEsMi4xMjYsMHY2LjM3OEExLjA2MywxLjA2MywwLDAsMSw1NSwzOC42ODJaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTQ0LjQ3OCw0My4wNDFhMS4wNiwxLjA2LDAsMCwxLS43NTItLjMxMmwtNC41MS00LjUwOWExLjA2MywxLjA2MywwLDAsMSwxLjUtMS41bDQuNTA5LDQuNTFhMS4wNjQsMS4wNjQsMCwwLDEtLjc1MSwxLjgxNVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNNDAuMTE5LDUzLjU2M0gzMy43NDFhMS4wNjMsMS4wNjMsMCwwLDEsMC0yLjEyNmg2LjM3OGExLjA2MywxLjA2MywwLDAsMSwwLDIuMTI2WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0zOS45NjgsNjguNmExLjA2MywxLjA2MywwLDAsMS0uNzUyLTEuODE0bDQuNTEtNC41MWExLjA2MywxLjA2MywwLDAsMSwxLjUsMS41bC00LjUwOSw0LjUxQTEuMDU5LDEuMDU5LDAsMCwxLDM5Ljk2OCw2OC42WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik01NSw3NC44MjFhMS4wNjIsMS4wNjIsMCwwLDEtMS4wNjMtMS4wNjNWNjcuMzgxYTEuMDYzLDEuMDYzLDAsMCwxLDIuMTI2LDB2Ni4zNzdBMS4wNjIsMS4wNjIsMCwwLDEsNTUsNzQuODIxWiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik03MC4wMzMsNjguNmExLjA1OSwxLjA1OSwwLDAsMS0uNzUyLS4zMTFsLTQuNTEtNC41MWExLjA2MywxLjA2MywwLDAsMSwxLjUtMS41bDQuNTEsNC41MWExLjA2MywxLjA2MywwLDAsMS0uNzUxLDEuODE0WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik03Ni4yNTksNTMuNTYzSDY5Ljg4MWExLjA2MywxLjA2MywwLDAsMSwwLTIuMTI2aDYuMzc4YTEuMDYzLDEuMDYzLDAsMCwxLDAsMi4xMjZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTY1LjUyMiw0My4wNDFhMS4wNjQsMS4wNjQsMCwwLDEtLjc1MS0xLjgxNWw0LjUxLTQuNTFhMS4wNjMsMS4wNjMsMCwwLDEsMS41LDEuNWwtNC41MSw0LjUwOUExLjA2LDEuMDYsMCwwLDEsNjUuNTIyLDQzLjA0MVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNMTI5LjkxMywzNy42MzFoMi40OTV2MjQuMTloLTIuNDk1WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0xMzguODQxLDM5LjE2N2ExLjgyMiwxLjgyMiwwLDAsMSwxLjgyMywxLjgyNCwxLjgyNCwxLjgyNCwwLDAsMS0zLjY0NywwQTEuODIzLDEuODIzLDAsMCwxLDEzOC44NDEsMzkuMTY3Wm0tMS4yNDgsNy42OGgyLjVWNjEuODIxaC0yLjVaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTE1OS45OTEsNjEuMTQ5YzAsNS40MDgtMi45MTEsOC4zNTItOC4xNTksOC4zNTJhOS43MzQsOS43MzQsMCwwLDEtNy4zNTktMi44NDhsMS43OTItMi4wNDhhNy4xNDYsNy4xNDYsMCwwLDAsNS41NjcsMi41OTJjNC40OCwwLDUuNjY0LTIuODgsNS42NjQtNi4wNDh2LTEuOTJoLS4wNjRhNi4xMiw2LjEyLDAsMCwxLTUuMjgsMi43ODVjLTQuNywwLTcuOTY3LTMuMjY1LTcuOTY3LTcuNjgsMC00LjksMy4yLTcuODcyLDcuOTY3LTcuODcyYTUuODc4LDUuODc4LDAsMCwxLDUuMjgsMi45NDRoLjA2NFY0Ni44NDdoMi41Wm0tNy44MzktMS40NEE1LjE3OCw1LjE3OCwwLDAsMCwxNTcuNSw1NC4yN2E1LjE4Myw1LjE4MywwLDAsMC01LjM0NC01LjUsNS40NzQsNS40NzQsMCwwLDAsMCwxMC45NDJaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTE2NC42LDM3LjYzMWgyLjV2MTEuM2guMDY0YTUuNjExLDUuNjExLDAsMCwxLDQuOC0yLjQ2NGMzLjkzNiwwLDUuNjk1LDIuNSw1LjY5NSw2LjExMnY5LjI0N2gtMi41VjUyLjgzYzAtMi41LTEuMDg4LTQuMDYzLTMuNDI0LTQuMDYzLTMuMjMyLDAtNC42NCwyLjMzNi00LjY0LDUuNzU4djcuM2gtMi41WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0xOTAuNTg0LDQ4Ljk1OGgtNC40MTZ2Ny40ODdjMCwxLjkyLjAzMiwzLjQ1NiwyLjI0LDMuNDU2YTQuODY3LDQuODY3LDAsMCwwLDIuMjA3LS41MTFsLjEsMi4yNzFhNy41OCw3LjU4LDAsMCwxLTIuOTExLjU0NGMtMy41NTIsMC00LjEyOC0xLjkyLTQuMTI4LTUuMDIzVjQ4Ljk1OGgtMy4yNjRWNDYuODQ3aDMuMjY0VjQyLjU5MWgyLjV2NC4yNTZoNC40MTZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PC9zdmc+",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 24,
            "editorY": 317
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "HumidityColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 7,
                  "y": 220,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 7,
                  "y": 220,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 220,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDc8L3RpdGxlPjxjaXJjbGUgY3g9IjU1IiBjeT0iNTIuNSIgcj0iMzUuNzE0IiBzdHlsZT0iZmlsbDojNzM4NWJmIi8+PHBhdGggZD0iTTEyOS42ODksMzcuNjMxaDIuNXYxMS4zaC4wNjRhNS42MTEsNS42MTEsMCwwLDEsNC44LTIuNDYzYzMuOTM1LDAsNS42OTUsMi40OTUsNS42OTUsNi4xMTF2OS4yNDdoLTIuNVY1Mi44M2MwLTIuNS0xLjA4OC00LjA2NC0zLjQyNC00LjA2NC0zLjIzMiwwLTQuNjQsMi4zMzYtNC42NCw1Ljc1OXY3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNMTYwLjUzNiw1OC4yN2MwLDEuMzc2LjEyOCwyLjU2LjEyOCwzLjU1MUgxNTguM2MwLS44LS4wNjQtMS42MzItLjA2NC0yLjQ2NGgtLjA2NGE1LjQzMyw1LjQzMywwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDZoMi41djguOTkyYzAsMi41LDEuMDg4LDQuMDYzLDMuNDI0LDQuMDYzLDMuMjMxLDAsNC42NC0yLjMzNiw0LjY0LTUuNzU5di03LjNoMi41WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0xNjUuMjczLDUwLjRjMC0xLjM3Ni0uMTI4LTIuNTYtLjEyOC0zLjU1MmgyLjM2OGMwLC44LjA2NCwxLjYzMy4wNjQsMi40NjVoLjA2NGE1LjQzNiw1LjQzNiwwLDAsMSw0Ljk5Mi0yLjg0OGMzLjIzMSwwLDQuMjU1LDEuODIzLDQuNzM1LDIuODQ4YTUuMiw1LjIsMCwwLDEsNC43MzYtMi44NDhjNC4yODgsMCw1LjY5NSwyLjQsNS42OTUsNi4yNzF2OS4wODdoLTIuNXYtOC45NmMwLTIuMDc5LS43MzYtNC4wOTUtMy42NDgtNC4wOTUtMi4xMTIsMC0zLjg3MiwxLjcyOC0zLjg3Miw0LjQxNnY4LjYzOWgtMi41VjUzLjM0MmMwLTMuMy0uODMyLTQuNTc2LTIuODgtNC41NzYtMy4yMzIsMC00LjY0LDIuMzM2LTQuNjQsNS43NTl2Ny4zaC0yLjVaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTE5NC4wMDksMzkuMTY3YTEuODIzLDEuODIzLDAsMCwxLDEuODI0LDEuODIzLDEuODI0LDEuODI0LDAsMCwxLTMuNjQ4LDBBMS44MjMsMS44MjMsMCwwLDEsMTk0LjAwOSwzOS4xNjdabS0xLjI0OCw3LjY3OWgyLjVWNjEuODIxaC0yLjVaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTIxMi42NjQsNTkuMTY2SDIxMi42YTYuNDg3LDYuNDg3LDAsMCwxLTUuNzYsMy4wMzksNy41NjgsNy41NjgsMCwwLDEtNy40ODctNy44NzEsNy41NDIsNy41NDIsMCwwLDEsNy44NzEtNy44NzEsNi45NDIsNi45NDIsMCwwLDEsNS4zNzYsMi41NTloLjA2NFYzNy42MzFoMi41djI0LjE5aC0yLjVabS01LjMxMi0xMC40YTUuMjI3LDUuMjI3LDAsMCwwLTUuMzExLDUuNTY4LDUuMzE3LDUuMzE3LDAsMSwwLDEwLjYyMywwQTUuMjI4LDUuMjI4LDAsMCwwLDIwNy4zNTIsNDguNzY2WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0yMjEuMjQsMzkuMTY3YTEuODIzLDEuODIzLDAsMCwxLDEuODI0LDEuODIzLDEuODI0LDEuODI0LDAsMSwxLTMuNjQ4LDBBMS44MjMsMS44MjMsMCwwLDEsMjIxLjI0LDM5LjE2N1ptLTEuMjQ4LDcuNjc5aDIuNVY2MS44MjFoLTIuNVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNMjM1LjYzOSw0OC45NThoLTQuNDE1djcuNDg3YzAsMS45Mi4wMzIsMy40NTYsMi4yMzksMy40NTZhNC44NjgsNC44NjgsMCwwLDAsMi4yMDgtLjUxMWwuMSwyLjI3MWE3LjU4OSw3LjU4OSwwLDAsMS0yLjkxMi41NDRjLTMuNTUxLDAtNC4xMjctMS45Mi00LjEyNy01LjAyM1Y0OC45NThoLTMuMjY0VjQ2Ljg0NmgzLjI2NFY0Mi41OTFoMi41djQuMjU1aDQuNDE1WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjxwYXRoIGQ9Ik0yNDQuMjE1LDY1LjI0NWMtLjk5MiwyLjUyOC0xLjk4NCw0LjI1Ni00Ljk5MSw0LjI1NmE1LjQyNyw1LjQyNywwLDAsMS0yLjI0LS4zODRsLjMyLTIuMTc2YTQuODU0LDQuODU0LDAsMCwwLDEuNzU5LjI1NmMxLjYzMiwwLDIuMjQtLjk5MiwyLjc4NC0yLjQ2NWwxLjAyNC0yLjgxNC02LjIwNy0xNS4wNzJoMi45MTJsNC42MzksMTEuNzQ0aC4wNjRsNC40NDgtMTEuNzQ0aDIuNzJaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTU1LDEwMi41YTUwLDUwLDAsMSwxLDUwLTUwQTUwLjA1Nyw1MC4wNTcsMCwwLDEsNTUsMTAyLjVaTTU1LDQuMjg2QTQ4LjIxNCw0OC4yMTQsMCwxLDAsMTAzLjIxNCw1Mi41LDQ4LjI2OCw0OC4yNjgsMCwwLDAsNTUsNC4yODZaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTYwLjcxNCw0Mi43NDVsLS4wNTctLjA3Ni4wNjctLjA2OGMuMTA4LS4xMTIuNTU2LS41NTcuNjg5LS42OWwuMDM3LS4wMzdjLjIwNi0uMjc0LjMxOC0uNjY4LjA4NC0uOWEuNjg2LjY4NiwwLDAsMC0xLjAyNi0uMTU4aDBzLS4wMi4wMTgtLjMzMy4yNjVjLS4xOS4xNS0uNC4zMTgtLjQ3My4zNzVsLS4wNzcuMDYyLS4wNzEtLjA2OWExMS4wMzcsMTEuMDM3LDAsMCwwLTE4LjcyOCw3LjkyOCwxMS4xMTEsMTEuMTExLDAsMCwwLDMuNjQ3LDguMTc3Ljc4OC43ODgsMCwwLDAsMS4wNS0xLjE3NCw5LjQ1Nyw5LjQ1NywwLDAsMSw2LjM1Mi0xNi40OSw5LjUsOS41LDAsMCwxLDYuNDM3LDIuNDg1bC4xLjA4OS0uMS4wODFjLTEuOTIyLDEuNTE1LTQuMDc1LDMuMTk0LTUuNTMxLDQuMzI5bC0uNTM0LjQxNi0uMDQ4LS4wMDdhMi4wMjUsMi4wMjUsMCwwLDAtLjMxNy0uMDI3QTIuMTIxLDIuMTIxLDAsMSwwLDU0LDQ5LjQ1NHYtLjA0M2wuMDMxLS4wMzFjMS4wNDItMS4wNTEsMi43OTItMi44Miw0LjQ5My00LjUzOWwxLjA0Mi0xLjA1Mi4wNzcuMTA5YTkuNTEyLDkuNTEyLDAsMCwxLDEuNzIyLDUuNDc3LDkuNCw5LjQsMCwwLDEtMy4xMzQsNywuNzg4Ljc4OCwwLDAsMCwxLjA1LDEuMTc0LDExLjExLDExLjExLDAsMCwwLDMuNjQ2LTguMTc2QTEwLjk3OCwxMC45NzgsMCwwLDAsNjAuNzE0LDQyLjc0NVoiIHN0eWxlPSJmaWxsOiNjOWQyMDAiLz48cGF0aCBkPSJNNjcuNCw1OS4yMzFhLjc4MS43ODEsMCwwLDAtLjczMS0xLjE1aC0uMDgxYS43NzYuNzc2LDAsMCwwLS41NzcuNDM4Yy0uMDcxLjE0Mi0uMTg4LjM1Ny0uMzM2LjYyNy0uMzMyLjYwNi0uODMzLDEuNTIxLTEuMjgyLDIuNWExMS4zMiwxMS4zMiwwLDAsMC0xLjI0Niw0LjQ3M0E1LjMyMyw1LjMyMywwLDAsMCw2NC45MjQsNzBhLjc5NC43OTQsMCwwLDAsLjguMjM3Ljc4Ljc4LDAsMCwwLC4yNTctMS4zNzYsMy45MywzLjkzLDAsMCwxLTEuMjcyLTIuNzQsMTAuMzMyLDEwLjMzMiwwLDAsMSwxLjEtMy44MTNjLjQtLjg3OC44MzQtMS42NjcsMS4xOC0yLjNDNjcuMTU1LDU5LjcsNjcuMyw1OS40MzQsNjcuNCw1OS4yMzFaIiBzdHlsZT0iZmlsbDojYzlkMjAwIi8+PHBhdGggZD0iTTczLjA2OSw1NS4xODJjLS44MTktMS4zMjMtMS41OTQtMi40MzMtMi4yNTYtMy4zNzFsLS4wMjUtLjAzNC4wMDUtLjA0M2EyMS4zNzcsMjEuMzc3LDAsMCwwLC4xNjctMi4zNTlBMTguOTQyLDE4Ljk0MiwwLDEsMCw1OS41MzEsNjYuOTA3bC4xMzMtLjA1OS4wMjIuMTQ0YTguODg3LDguODg3LDAsMCwwLDguNzA3LDcuNzE4LDkuMDE0LDkuMDE0LDAsMCwwLDguODE3LTkuMThDNzcuMjEsNjIuMjY3LDc1LDU4LjI4Niw3My4wNjksNTUuMTgyWk02MC4zNiw2Mi44YTEwLjczMiwxMC43MzIsMCwwLDAtLjQxNCwyLjI2NWwwLC4wNjQtLjA1OC4wMjlBMTcuNTY1LDE3LjU2NSwwLDAsMSwzNC43LDQ5LjM3NWExNy41MjMsMTcuNTIzLDAsMSwxLDM1LjA0NSwwdi40NzdsLS4yLS4yNjctLjE5NC0uMjUtLjYxLS43OC0uNjA5Ljc4cy0uMTcxLjI0Ny0uMi4yNzlsLS4yLjI1N3YtLjQ5MUExNS4yNzgsMTUuMjc4LDAsMCwwLDU3LjQ3MywzNC43MzRhMTUuNzA5LDE1LjcwOSwwLDAsMC0xNS4yODUsMi44MkExNS41LDE1LjUsMCwwLDAsNjAuMiw2Mi42NzJsLjI0Mi0uMTQ0Wm01LjQ2Ni0xMy40MjNhMTQuNTMzLDE0LjUzMywwLDAsMS0uMzkzLDMuMmwtLjAxNy4wMzktLjAyNy4wMzljLS41NC43ODUtMS4xLDEuNi0xLjY3MiwyLjUyNGE0NS45NjEsNDUuOTYxLDAsMCwwLTIuNSw0LjUzNmwtLjAyNy4wMzZhMTMuOTQzLDEzLjk0MywwLDEsMSw0LjY0MS0xMC4zNzlabTIuNTY3LDIzLjc3MmE3LjQsNy40LDAsMCwxLTcuMjU1LTcuMzYyLDEuMDIzLDEuMDIzLDAsMCwwLDAtLjI0MSwxMy4wNDUsMTMuMDQ1LDAsMCwxLDEuMzc2LTQuODU5LjMuMywwLDAsMCwuMDI2LS4wNTFsLjAxMy0uMDMxLjAzMi0uMDI2YS43NzIuNzcyLDAsMCwwLC4xNDQtLjM2MWwuMDA5LS4wMzVhNDEuMjYyLDQxLjI2MiwwLDAsMSwyLjMtNC4xNjhjLjYyOS0xLjAxNywxLjE2NC0xLjgsMS42NDktMi40ODlhLjg1NS44NTUsMCwwLDAsLjIwOS0uMzM0bC4wMTUtLjAyOWMuNDkzLS42OTIuOS0xLjIwOCwxLjE5My0xLjU4NGwuMjkyLS4zNzUuMTQ4LjE4OWMuMTczLjIyMi40NTkuNTg4LjcuOWwuMDE3LjAzNWEuNzgzLjc4MywwLDAsMCwuMzQyLjQ0bC4wMzIuMDI5Yy42LjgyMywxLjI5MywxLjg3NSwyLjEyNSwzLjIxNi45MTQsMS40NzMsMy45LDYuNTEyLDMuOSw5LjUxN0E3LjM2Myw3LjM2MywwLDAsMSw2OC4zOTMsNzMuMTQ3WiIgc3R5bGU9ImZpbGw6I2M5ZDIwMCIvPjwvc3ZnPg==",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 25,
            "editorY": 155
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "TemperatureColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 150,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 150,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 23,
                  "y": 120,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDY8L3RpdGxlPjxjaXJjbGUgY3g9IjU1IiBjeT0iNTIuNSIgcj0iMzUuNzE0IiBzdHlsZT0iZmlsbDojNzM4NWJmIi8+PHBhdGggZD0iTTEzNi45ODgsNDguOTU4aC00LjQxNnY3LjQ4N2MwLDEuOTIuMDMyLDMuNDU2LDIuMjQsMy40NTZhNC44NzEsNC44NzEsMCwwLDAsMi4yMDgtLjUxMWwuMSwyLjI3MWE3LjU4OSw3LjU4OSwwLDAsMS0yLjkxMi41NDRjLTMuNTUyLDAtNC4xMjctMS45Mi00LjEyNy01LjAyM1Y0OC45NThoLTMuMjY0VjQ2Ljg0NmgzLjI2NFY0Mi41OTFoMi41djQuMjU1aDQuNDE2WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xNTMuNDM1LDU5LjFhNy42ODMsNy42ODMsMCwwLDEtNi42NTUsMy4xYy00LjcsMC03LjU4NC0zLjUxOS03LjU4NC03Ljg3MWE3LjUsNy41LDAsMCwxLDcuNjc5LTcuODcxYzQuMjI1LDAsNy4xLDIuODc5LDcuMSw3LjgzOXYuOGgtMTIuMWE1LjAwNyw1LjAwNywwLDAsMCw0LjksNC44LDUuNTc4LDUuNTc4LDAsMCwwLDQuNzY3LTIuMjcyWm0tMi4xNDMtNi4xMTJhNC4xNjQsNC4xNjQsMCwwLDAtNC41MTItNC4yMjQsNC42MzQsNC42MzQsMCwwLDAtNC45LDQuMjI0WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xNTcuODUyLDUwLjRjMC0xLjM3Ni0uMTI4LTIuNTYtLjEyOC0zLjU1MmgyLjM2OGMwLC44LjA2NCwxLjYzMy4wNjQsMi40NjVoLjA2NGE1LjQzNiw1LjQzNiwwLDAsMSw0Ljk5Mi0yLjg0OGMzLjIzMSwwLDQuMjU1LDEuODIzLDQuNzM1LDIuODQ4YTUuMiw1LjIsMCwwLDEsNC43MzYtMi44NDhjNC4yODgsMCw1LjY5NSwyLjQsNS42OTUsNi4yNzF2OS4wODdoLTIuNDk1di04Ljk2YzAtMi4wNzktLjczNi00LjA5NS0zLjY0OC00LjA5NS0yLjExMiwwLTMuODcyLDEuNzI4LTMuODcyLDQuNDE2djguNjM5aC0yLjVWNTMuMzQyYzAtMy4zLS44MzItNC41NzYtMi44OC00LjU3Ni0zLjIzMiwwLTQuNjQsMi4zMzYtNC42NCw1Ljc1OXY3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTg0Ljk4OCw0Ni44NDZoMi41djIuMTc2aC4wNjRhNi45NDIsNi45NDIsMCwwLDEsNS4zNzUtMi41NTksNy41NDMsNy41NDMsMCwwLDEsNy44NzIsNy44NzEsNy41NjksNy41NjksMCwwLDEtNy40ODgsNy44NzEsNi40ODYsNi40ODYsMCwwLDEtNS43NTktMy4wMzloLS4wNjR2OS45NTFoLTIuNVpNMTkyLjgsNTkuOWE1LjIyNyw1LjIyNywwLDAsMCw1LjMxMi01LjU2Nyw1LjMxNyw1LjMxNywwLDEsMC0xMC42MjMsMEE1LjIyNiw1LjIyNiwwLDAsMCwxOTIuOCw1OS45WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMTguMDQyLDU5LjFhNy42ODEsNy42ODEsMCwwLDEtNi42NTUsMy4xYy00LjcsMC03LjU4My0zLjUxOS03LjU4My03Ljg3MWE3LjUsNy41LDAsMCwxLDcuNjc5LTcuODcxYzQuMjI0LDAsNy4xLDIuODc5LDcuMSw3LjgzOXYuOEgyMDYuNDkyYTUuMDA2LDUuMDA2LDAsMCwwLDQuOSw0LjgsNS41NzksNS41NzksMCwwLDAsNC43NjgtMi4yNzJaTTIxNS45LDUyLjk5YTQuMTYzLDQuMTYzLDAsMCwwLTQuNTEyLTQuMjI0LDQuNjMzLDQuNjMzLDAsMCwwLTQuOSw0LjIyNFoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjIyLjQ1OSw1MC40YzAtMS4zNzYtLjEyNy0yLjU2LS4xMjctMy41NTJIMjI0LjdjMCwuOC4wNjUsMS42MzMuMDY1LDIuNDY1aC4wNjRhNS40MzQsNS40MzQsMCwwLDEsNC45OTEtMi44NDgsMi45NDIsMi45NDIsMCwwLDEsMS4wMjQuMTZsLS4xNiwyLjUyN2E0LjcwNiw0LjcwNiwwLDAsMC0xLjM0NC0uMTkyYy0zLjA0LDAtNC4zODMsMi4xNDQtNC4zODMsNS41Njd2Ny4zaC0yLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIzMy41MzEsNDguNzY2YTguMzM1LDguMzM1LDAsMCwxLDUuOTUyLTIuM2M0LjQxNSwwLDYuMjcxLDIuMTExLDYuMjcxLDYuMzM1djYuNDMxYTE2LjYxNywxNi42MTcsMCwwLDAsLjIyNSwyLjU5MmgtMi40YTEwLjY0NCwxMC42NDQsMCwwLDEtLjE2MS0yLjIzOWgtLjA2NGE1LjY2LDUuNjYsMCwwLDEtNC45MjcsMi42MjNjLTMuMDQsMC01LjU2OC0xLjUzNS01LjU2OC00LjQ0NywwLTQuOTYsNS43Ni01LjI0OCw5LjQ0LTUuMjQ4aC45NnYtLjQ0N2MwLTIuMTc2LTEuMzc2LTMuMy0zLjcxMi0zLjNBNi42NDgsNi42NDgsMCwwLDAsMjM1LjEsNTAuNFptNy4yMzIsNS44NTVjLTMuMTY4LDAtNS4yMTYuODY1LTUuMjE2LDIuODgxLDAsMS44ODgsMS40MDgsMi41OTIsMy4zLDIuNTkyLDIuODgsMCw0LjM1Mi0yLjA4LDQuNDE2LTQuNTEydi0uOTYxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yNTguNTIyLDQ4Ljk1OGgtNC40MTV2Ny40ODdjMCwxLjkyLjAzMiwzLjQ1NiwyLjI0LDMuNDU2YTQuODcxLDQuODcxLDAsMCwwLDIuMjA4LS41MTFsLjA5NSwyLjI3MWE3LjU4LDcuNTgsMCwwLDEtMi45MTEuNTQ0Yy0zLjU1MiwwLTQuMTI4LTEuOTItNC4xMjgtNS4wMjNWNDguOTU4aC0zLjI2NFY0Ni44NDZoMy4yNjRWNDIuNTkxaDIuNXY0LjI1NWg0LjQxNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjc0LjY1LDU4LjI3YzAsMS4zNzYuMTI4LDIuNTYuMTI4LDMuNTUxSDI3Mi40MWMwLS44LS4wNjQtMS42MzItLjA2NC0yLjQ2NGgtLjA2NGE1LjQzNiw1LjQzNiwwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDZoMi41djguOTkyYzAsMi41LDEuMDg4LDQuMDYzLDMuNDI0LDQuMDYzLDMuMjMxLDAsNC42MzktMi4zMzYsNC42MzktNS43NTl2LTcuM2gyLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTI3OS4zODcsNTAuNGMwLTEuMzc2LS4xMjgtMi41Ni0uMTI4LTMuNTUyaDIuMzY4YzAsLjguMDY0LDEuNjMzLjA2NCwyLjQ2NWguMDY0YTUuNDM2LDUuNDM2LDAsMCwxLDQuOTkxLTIuODQ4LDIuOTUsMi45NSwwLDAsMSwxLjAyNS4xNmwtLjE2MSwyLjUyN2E0LjcsNC43LDAsMCwwLTEuMzQzLS4xOTJjLTMuMDQsMC00LjM4NCwyLjE0NC00LjM4NCw1LjU2N3Y3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMzAzLjQ1LDU5LjFhNy42ODQsNy42ODQsMCwwLDEtNi42NTYsMy4xYy00LjcsMC03LjU4My0zLjUxOS03LjU4My03Ljg3MWE3LjUsNy41LDAsMCwxLDcuNjc5LTcuODcxYzQuMjI0LDAsNy4xLDIuODc5LDcuMSw3LjgzOXYuOEgyOTEuOWE1LjAwNyw1LjAwNywwLDAsMCw0Ljg5NSw0LjgsNS41NzksNS41NzksMCwwLDAsNC43NjgtMi4yNzJabS0yLjE0NC02LjExMmE0LjE2Myw0LjE2MywwLDAsMC00LjUxMi00LjIyNEE0LjYzMyw0LjYzMywwLDAsMCwyOTEuOSw1Mi45OVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNNTUsMTAyLjVhNTAsNTAsMCwxLDEsNTAtNTBBNTAuMDU3LDUwLjA1NywwLDAsMSw1NSwxMDIuNVpNNTUsNC4yODZBNDguMjE0LDQ4LjIxNCwwLDEsMCwxMDMuMjE0LDUyLjUsNDguMjY4LDQ4LjI2OCwwLDAsMCw1NSw0LjI4NloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNNjAuMzU3LDU0Ljl2LS42MTRoMi42NzlhLjg5My44OTMsMCwxLDAsMC0xLjc4Nkg2MC4zNTdWNTAuNzE0aDIuNjc5YS44OTMuODkzLDAsMSwwLDAtMS43ODVINjAuMzU3VjQ3LjE0M2gyLjY3OWEuODkzLjg5MywwLDEsMCwwLTEuNzg2SDYwLjM1N1Y0My41NzJoMi42NzlhLjg5My44OTMsMCwxLDAsMC0xLjc4Nkg2MC4zNTdWNDBoMi42NzlhLjg5My44OTMsMCwxLDAsMC0xLjc4Nkg2MC4zNTdWMzQuNjQzYTQuMTU3LDQuMTU3LDAsMCwwLTEuNjc0LTMuNDMyLDcuMDg4LDcuMDg4LDAsMCwwLTcuMzY2LDAsNC4xNTcsNC4xNTcsMCwwLDAtMS42NzQsMy40MzJWNTQuOWExMC42NDEsMTAuNjQxLDAsMCwwLTUuMzU2LDkuNDA1LDEwLjcxNCwxMC43MTQsMCwwLDAsMjEuNDI3LS4yQTEwLjY0NCwxMC42NDQsMCwwLDAsNjAuMzU3LDU0LjlabS0xLjc4Ni40NzRhLjg5NC44OTQsMCwwLDAsLjQ3NS43ODEsOC45MjksOC45MjksMCwxLDEtOC4wOTIsMCwuODkzLjg5MywwLDAsMCwuNDc0LS43ODFWMzQuNjQzYTIuMTg5LDIuMTg5LDAsMCwxLC45NDktMS45ODEsNS4yNzcsNS4yNzcsMCwwLDEsNS4yNDYsMCwyLjE5MSwyLjE5MSwwLDAsMSwuOTQ4LDEuOTgxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjwvc3ZnPg==",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 25,
            "editorY": 76
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AirQualityColor",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 360,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 200,
                  "height": 100,
                  "x": 6,
                  "y": 360,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 300,
                  "height": 100,
                  "x": 20,
                  "y": 420,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMTAiIGhlaWdodD0iMTA1IiB2aWV3Qm94PSIwIDAgMzEwIDEwNSI+PHRpdGxlPkFydGJvYXJkIDEwPC90aXRsZT48Y2lyY2xlIGN4PSI1NSIgY3k9IjUyLjUiIHI9IjM1LjcxNCIgc3R5bGU9ImZpbGw6IzczODViZiIvPjxwYXRoIGQ9Ik01NSwxMDIuNWE1MCw1MCwwLDEsMSw1MC01MEE1MC4wNTcsNTAuMDU3LDAsMCwxLDU1LDEwMi41Wk01NSw0LjI4NkE0OC4yMTQsNDguMjE0LDAsMSwwLDEwMy4yMTQsNTIuNSw0OC4yNjgsNDguMjY4LDAsMCwwLDU1LDQuMjg2WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik00MS45NzksMzAuMTc5YTIuNzksMi43OSwwLDAsMC0yLjc5LDIuNzl2MTAuN2EyNS45LDI1LjksMCwwLDAtNi41MS0xLjR2MS44NmEyNi44LDI2LjgsMCwwLDEsNi41MSwxLjQ4M3Y1LjQ5M2EyNS44NTMsMjUuODUzLDAsMCwwLTYuNTEtMS4zOTV2MS44NmEyNi43ODQsMjYuNzg0LDAsMCwxLDYuNTEsMS40ODJ2NS40OTNhMjUuOSwyNS45LDAsMCwwLTYuNTEtMS40djEuODZhMjYuOCwyNi44LDAsMCwxLDYuNTEsMS40ODNWNzIuMDMxYTIuNzksMi43OSwwLDAsMCwyLjc5LDIuNzlINjguMDIxYTIuNzksMi43OSwwLDAsMCwyLjc5LTIuNzlWNjMuMjgzbC0xLjg2LS41NTJ2OS4zYS45My45MywwLDAsMS0uOTMuOTNINDEuOTc5YS45My45MywwLDAsMS0uOTMtLjkzVjMyLjk2OWEuOTMuOTMsMCwwLDEsLjkzLS45M0g2OC4wMjFhLjkzLjkzLDAsMCwxLC45My45M1Y0My45ODRhMjguNDc0LDI4LjQ3NCwwLDAsMC03LjQ0MS0xLjcxNWMtMi4wNDUsMC00LjU1NSwxLjAxOC02Ljk3NSwxLjk0OC0yLjIzMS44MzUtNC40NjUsMS43NzMtNi4wNDUsMS43NzNhMjQuNTU0LDI0LjU1NCwwLDAsMS01LjU4MS0xLjIyMXYxLjU2N2EyMi4zODcsMjIuMzg3LDAsMCwwLDUuNTgxLDEuMTA1YzEuOTU0LDAsNC4yNjUtLjkzLDYuNjg0LTEuODYsMi4yMzEtLjkzMSw0LjU3MS0xLjg2MSw2LjMzNi0xLjg2MXM0LjczMS45Myw3LjYxNSwxLjg2MWMzLjE2MS45Myw2LjE1MSwxLjg2LDguMiwxLjg2VjQ1Ljk5YTMwLjAxNCwzMC4wMTQsMCwwLDEtNi41MS0xLjQ1NFYzMi45NjlhMi43OSwyLjc5LDAsMCwwLTIuNzktMi43OVpNNjEuNTEsNDkuM2MtMi4wNDUsMC00LjU1NSwxLjAxNy02Ljk3NSwxLjk0Ny0yLjIzMS44MzYtNC40NjUsMS43NzMtNi4wNDUsMS43NzNBMjQuNSwyNC41LDAsMCwxLDQyLjkwOSw1MS44djEuOTc3YTIyLjQyNCwyMi40MjQsMCwwLDAsNS41ODEsMS4xYzEuOTU0LDAsNC4yNjUtLjkzLDYuNjg0LTEuODYsMi4yMzEtLjkzLDQuNTcxLTEuODYsNi4zMzYtMS44NnM0LjczMS45Myw3LjYxNSwxLjg2YzMuMTYxLjkzLDYuMTUxLDEuODYsOC4yLDEuODZ2LTEuODZjLTEuNjc0LDAtNC43My0uOTM3LTcuNjE0LTEuNzczQzY2LjU0Niw1MC4yMjQsNjMuNTU2LDQ5LjMsNjEuNTEsNDkuM1ptMCw3LjQ0Yy0yLjA0NSwwLTQuNTU1LDEuMDE4LTYuOTc1LDEuOTQ4LTIuMjMxLjgzNS00LjQ2NSwxLjc3My02LjA0NSwxLjc3M2EyNC41NTQsMjQuNTU0LDAsMCwxLTUuNTgxLTEuMjIxdjEuOTc2YTIyLjQzMywyMi40MzMsMCwwLDAsNS41ODEsMS4xMDVjMS45NTQsMCw0LjI2NS0uOTMsNi42ODQtMS44NiwyLjIzMS0uOTMxLDQuNTcxLTEuODYxLDYuMzM2LTEuODYxLDIuMjMxLDAsNS4wMSwxLjAyNSw3LjYxNSwxLjg2MSwzLjE2MS45Myw2LjE1MSwxLjg2LDguMiwxLjg2di0xLjg2Yy0xLjY3NCwwLTQuNzMtLjkzOC03LjYxNC0xLjc3M0M2Ni41NDYsNTcuNjY0LDYzLjU1Niw1Ni43NDEsNjEuNTEsNTYuNzQxWiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0xMjkuNSw0OC43NjdhOC4zMzMsOC4zMzMsMCwwLDEsNS45NTItMi4zYzQuNDE1LDAsNi4yNzIsMi4xMTIsNi4yNzIsNi4zMzZ2Ni40MzFhMTYuNjEzLDE2LjYxMywwLDAsMCwuMjIzLDIuNTkyaC0yLjRhMTAuNzA5LDEwLjcwOSwwLDAsMS0uMTYtMi4yNGgtLjA2NWE1LjY2MSw1LjY2MSwwLDAsMS00LjkyNywyLjYyNGMtMy4wMzksMC01LjU2OC0xLjUzNi01LjU2OC00LjQ0NywwLTQuOTYsNS43Ni01LjI0OCw5LjQ0LTUuMjQ4aC45NnYtLjQ0OGMwLTIuMTc2LTEuMzc2LTMuMjk1LTMuNzEyLTMuMjk1YTYuNjUsNi42NSwwLDAsMC00LjQ0OSwxLjYzMVptNy4yMzIsNS44NTVjLTMuMTY4LDAtNS4yMTUuODYzLTUuMjE1LDIuODgsMCwxLjg4OCwxLjQwNywyLjU5MiwzLjI5NSwyLjU5MiwyLjg3OSwwLDQuMzUxLTIuMDgsNC40MTYtNC41MTJ2LS45NloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTQ3Ljc3LDM5LjE2N2ExLjgyMywxLjgyMywwLDAsMSwxLjgyMywxLjgyNCwxLjgyNCwxLjgyNCwwLDAsMS0zLjY0OCwwQTEuODIzLDEuODIzLDAsMCwxLDE0Ny43NywzOS4xNjdabS0xLjI0OSw3LjY4aDIuNVY2MS44MjFoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTUzLjk3Nyw1MC40YzAtMS4zNzYtLjEyOC0yLjU2LS4xMjgtMy41NTFoMi4zNjhjMCwuOC4wNjQsMS42MzIuMDY0LDIuNDY0aC4wNjRhNS40MzYsNS40MzYsMCwwLDEsNC45OTEtMi44NDksMi45NjUsMi45NjUsMCwwLDEsMS4wMjQuMTZsLS4xNiwyLjUyOGE0LjcsNC43LDAsMCwwLTEuMzQ0LS4xOTJjLTMuMDQsMC00LjM4MywyLjE0NS00LjM4Myw1LjU2N3Y3LjNoLTIuNVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMTg5LjA3OSw2OS4xMTdoLTIuNVY1OS42NDZoLS4wNjRhNi45NDUsNi45NDUsMCwwLDEtNS4zNzUsMi41NTksNy41NDMsNy41NDMsMCwwLDEtNy44NzMtNy44NzEsNy41Nyw3LjU3LDAsMCwxLDcuNDg4LTcuODcyLDYuNDg5LDYuNDg5LDAsMCwxLDUuNzYsMy4wNGguMDY0VjQ2Ljg0N2gyLjVabS03LjgwOC0yMC4zNWE1LjIyNiw1LjIyNiwwLDAsMC01LjMxLDUuNTY3LDUuMzE3LDUuMzE3LDAsMSwwLDEwLjYyMywwQTUuMjI3LDUuMjI3LDAsMCwwLDE4MS4yNzEsNDguNzY3WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMDYuNzQzLDU4LjI3YzAsMS4zNzYuMTI4LDIuNTU5LjEyOCwzLjU1MUgyMDQuNWMwLS44LS4wNjUtMS42MzItLjA2NS0yLjQ2NGgtLjA2NGE1LjQzNiw1LjQzNiwwLDAsMS00Ljk5MSwyLjg0OGMtMy45MzYsMC01LjctMi41LTUuNy02LjExMVY0Ni44NDdoMi41djguOTkxYzAsMi41LDEuMDg3LDQuMDYzLDMuNDIzLDQuMDYzLDMuMjMzLDAsNC42NDEtMi4zMzYsNC42NDEtNS43NTl2LTcuM2gyLjVaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIxMS4yODgsNDguNzY3YTguMzMzLDguMzMzLDAsMCwxLDUuOTUyLTIuM2M0LjQxNSwwLDYuMjcyLDIuMTEyLDYuMjcyLDYuMzM2djYuNDMxYTE2LjYxMywxNi42MTMsMCwwLDAsLjIyMywyLjU5MmgtMi40YTEwLjcwOSwxMC43MDksMCwwLDEtLjE2LTIuMjRoLS4wNjVhNS42NjEsNS42NjEsMCwwLDEtNC45MjcsMi42MjRjLTMuMDM5LDAtNS41NjgtMS41MzYtNS41NjgtNC40NDcsMC00Ljk2LDUuNzYtNS4yNDgsOS40NC01LjI0OGguOTZ2LS40NDhjMC0yLjE3Ni0xLjM3Ni0zLjI5NS0zLjcxMi0zLjI5NWE2LjY1LDYuNjUsMCwwLDAtNC40NDksMS42MzFabTcuMjMyLDUuODU1Yy0zLjE2OCwwLTUuMjE1Ljg2My01LjIxNSwyLjg4LDAsMS44ODgsMS40MDcsMi41OTIsMy4yOTUsMi41OTIsMi44NzksMCw0LjM1MS0yLjA4LDQuNDE2LTQuNTEydi0uOTZaIiBzdHlsZT0iZmlsbDojZmZiNTAwIi8+PHBhdGggZD0iTTIyOC4zMTMsMzcuNjMxaDIuNXYyNC4xOWgtMi41WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yMzcuMjQsMzkuMTY3YTEuODIyLDEuODIyLDAsMCwxLDEuODIzLDEuODI0LDEuODI0LDEuODI0LDAsMCwxLTMuNjQ3LDBBMS44MjMsMS44MjMsMCwwLDEsMjM3LjI0LDM5LjE2N1ptLTEuMjQ4LDcuNjhoMi41VjYxLjgyMWgtMi41WiIgc3R5bGU9ImZpbGw6I2ZmYjUwMCIvPjxwYXRoIGQ9Ik0yNTEuNjM5LDQ4Ljk1OGgtNC40MTZ2Ny40ODdjMCwxLjkyLjAzMywzLjQ1NiwyLjI0LDMuNDU2YTQuODcxLDQuODcxLDAsMCwwLDIuMjA4LS41MTFsLjEsMi4yNzFhNy41OTIsNy41OTIsMCwwLDEtMi45MTIuNTQ0Yy0zLjU1MiwwLTQuMTI3LTEuOTItNC4xMjctNS4wMjNWNDguOTU4aC0zLjI2NVY0Ni44NDdoMy4yNjVWNDIuNTkxaDIuNXY0LjI1Nmg0LjQxNloiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48cGF0aCBkPSJNMjYwLjIxNSw2NS4yNDVjLS45OTIsMi41MjctMS45ODUsNC4yNTYtNC45OTIsNC4yNTZhNS40MjksNS40MjksMCwwLDEtMi4yNC0uMzg0bC4zMi0yLjE3N2E0LjgzNyw0LjgzNywwLDAsMCwxLjc2LjI1N2MxLjYzMiwwLDIuMjQtLjk5MiwyLjc4NC0yLjQ2NGwxLjAyNC0yLjgxNi02LjIwOC0xNS4wN2gyLjkxMmw0LjY0LDExLjc0M2guMDY0bDQuNDQ4LTExLjc0M2gyLjcxOVoiIHN0eWxlPSJmaWxsOiNmZmI1MDAiLz48L3N2Zz4=",
            "scaling": "targetWidth",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "lastTrigger": "triggered",
            "editorX": 26,
            "editorY": 403
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        },
        {
          "name": "AppInterval",
          "type": "AppInterval",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null,
            "time": 1000,
            "startOnInitialize": true
          },
          "meta": {
            "editorX": 117,
            "editorY": 295,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "TemperatureCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "HumidityCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQualityCharacteristic",
                "targetAbility": "read"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "DoorLightCharacteristic",
                "targetAbility": "read"
              }
            ],
            "started": [],
            "paused": []
          }
        },
        {
          "name": "TemperatureCloudData",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 465,
            "editorY": 1,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "HumidityCloudData",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 472,
            "editorY": 166,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "DoorLightCloudData",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 472,
            "editorY": 452,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "AirQualityCloudData",
          "type": "AppCloudEvent",
          "variants": [
            "app"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 477,
            "editorY": 624,
            "lastTrigger": "sent"
          },
          "triggers": {
            "triggered": [],
            "sent": []
          }
        },
        {
          "name": "AirQualityCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(AirQualityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(AirQualityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), ATMO_PROPERTY(AirQualityCharacteristic, readDataType), ATMO_PROPERTY(AirQualityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(AirQualityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(AirQualityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(AirQualityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(AirQualityCharacteristic, instance),\n\t\tATMO_VARIABLE(AirQualityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(AirQualityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e75-a4ff-6f0cd50005f4",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 285,
            "editorY": 635,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "AirQualityCloudData",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "text": {
                    "code": "readData + \" ppb\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "AirQualityLabel",
                "targetAbility": "setText"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "AirQualityCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "TemperatureCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(TemperatureCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(TemperatureCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), ATMO_PROPERTY(TemperatureCharacteristic, readDataType), ATMO_PROPERTY(TemperatureCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\t&ATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(TemperatureCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(TemperatureCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(TemperatureCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(TemperatureCharacteristic, instance),\n\t\tATMO_VARIABLE(TemperatureCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(TemperatureCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e76-a4ff-6f0cd50005f1",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 272,
            "editorY": 57,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "TemperatureCloudData",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "text": {
                    "code": "readData.toFixed(1) + \" C\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "TemperatureLabel",
                "targetAbility": "setText"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "TemperatureCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "HumidityCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(HumidityCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(HumidityCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(HumidityCharacteristic, writeDataType), ATMO_PROPERTY(HumidityCharacteristic, readDataType), ATMO_PROPERTY(HumidityCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\t&ATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(HumidityCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(HumidityCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(HumidityCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(HumidityCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(HumidityCharacteristic, instance),\n\t\tATMO_VARIABLE(HumidityCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(HumidityCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e77-a4ff-6f0cd50005f2",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_FLOAT",
            "writeDataType": "ATMO_DATATYPE_FLOAT",
            "notifyDataType": "ATMO_DATATYPE_FLOAT"
          },
          "meta": {
            "editorX": 279,
            "editorY": 209,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "HumidityCloudData",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "text": {
                    "code": "readData.toFixed(1) + \" %\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "HumidityLabel",
                "targetAbility": "setText"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "HumidityCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "DoorLightCharacteristic",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(DoorLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(DoorLightCharacteristic, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(DoorLightCharacteristic, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(DoorLightCharacteristic, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(DoorLightCharacteristic, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(DoorLightCharacteristic, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(DoorLightCharacteristic, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(DoorLightCharacteristic, writeDataType), ATMO_PROPERTY(DoorLightCharacteristic, readDataType), ATMO_PROPERTY(DoorLightCharacteristic, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\t&ATMO_VARIABLE(DoorLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(DoorLightCharacteristic, bleServiceHandle), \n\t\tATMO_PROPERTY(DoorLightCharacteristic, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\tATMO_VARIABLE(DoorLightCharacteristic, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(DoorLightCharacteristic, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(DoorLightCharacteristic, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(DoorLightCharacteristic, instance),\n\t\tATMO_VARIABLE(DoorLightCharacteristic, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(DoorLightCharacteristic, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": 0,
            "bleServiceUuid": "1493dd8e-8c3e-4e74-a4ff-6f0cd50005f9",
            "bleCharacteristicUuid": "1493dd8e-8c3e-4e79-a4ff-6f0cd50005f3",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "writeDataType": "ATMO_DATATYPE_UNSIGNED_INT",
            "notifyDataType": "ATMO_DATATYPE_UNSIGNED_INT"
          },
          "meta": {
            "editorX": 309,
            "editorY": 492,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [
              {
                "mapping": {
                  "value": {
                    "code": "readData"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "DoorLightCloudData",
                "targetAbility": "send"
              },
              {
                "mapping": {
                  "text": {
                    "code": "readData + \" lx\""
                  }
                },
                "targetOrder": [
                  "text"
                ],
                "targetElement": "LightLabel",
                "targetAbility": "setText"
              }
            ],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "DoorLightCharacteristic",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "Header",
          "type": "AppUILabel",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 224,
                  "height": 24,
                  "x": 33,
                  "y": 43,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 224,
                  "height": 24,
                  "x": 33,
                  "y": 43,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 246,
                  "height": 24,
                  "x": 32,
                  "y": 24,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "text": "Is It Fresh?",
            "font": "36px Helvetica",
            "color": "#3020e6",
            "alignment": "left"
          },
          "meta": {
            "editorX": 722,
            "editorY": 194,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "Image",
          "type": "AppUIImage",
          "variants": [
            "app",
            "ui"
          ],
          "properties": {
            "errorData": null,
            "layouts": {
              "360": {
                "640": {
                  "width": 360,
                  "height": 640,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "375": {
                "667": {
                  "width": 375,
                  "height": 667,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              },
              "1024": {
                "768": {
                  "width": 1024,
                  "height": 768,
                  "x": 0,
                  "y": 0,
                  "rotation": 0,
                  "propertyOverlay": {}
                }
              }
            },
            "visible": true,
            "image": "data:image/jpg;base64,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",
            "scaling": "target",
            "pressedData": {
              "x": 0,
              "y": 0
            },
            "releasedData": {
              "x": 0,
              "y": 0
            },
            "overData": {
              "x": 0,
              "y": 0
            },
            "leftData": {
              "x": 0,
              "y": 0
            }
          },
          "meta": {
            "editorX": 710,
            "editorY": 537,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "pressed": [],
            "released": [],
            "over": [],
            "imageSet": []
          }
        }
      ]
    },
    "Cloud": {
      "type": "cloud",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {},
      "elements": [
        {
          "name": "TemperatureCloudData",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 87,
            "editorY": 13,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "{Temperature:value}"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "TemperatureCloudData",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "HumidityCloudData",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 85,
            "editorY": 103,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "{Humidity:value}"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "HumidityCloudData",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "DoorLightCloudData",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 88,
            "editorY": 325,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "{Light:value}"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              },
              {
                "mapping": {
                  "value": {
                    "code": "value > 10"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "LightsOn",
                "targetAbility": "check"
              }
            ]
          },
          "coupledElementName": "DoorLightCloudData",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "AirQualityCloudData",
          "type": "CloudEvent",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 85,
            "editorY": 455,
            "lastTrigger": "eventReceived"
          },
          "triggers": {
            "triggered": [],
            "eventReceived": [
              {
                "mapping": {
                  "value": {
                    "code": "{AirQuality:value}"
                  }
                },
                "targetOrder": [
                  "value"
                ],
                "targetElement": "SensorData",
                "targetAbility": "addData"
              }
            ]
          },
          "coupledElementName": "AirQualityCloudData",
          "coupledElementPlaneName": "App View"
        },
        {
          "name": "SensorData",
          "type": "CloudStorage",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 664,
            "editorY": 405,
            "lastTrigger": "dataAdded"
          },
          "triggers": {
            "triggered": [],
            "dataAdded": [],
            "dataUpdated": [],
            "dataRemoved": [],
            "dataQueried": []
          }
        },
        {
          "name": "CloudMeta",
          "type": "CloudMeta",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 856,
            "editorY": 141,
            "lastTrigger": "trigged"
          },
          "triggers": {
            "triggered": []
          }
        },
        {
          "name": "LightsOn",
          "type": "CloudCondition",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null,
            "value": null
          },
          "meta": {
            "editorX": 577,
            "editorY": 35,
            "lastTrigger": "conditionTrue"
          },
          "triggers": {
            "triggered": [],
            "conditionTrue": [
              {
                "mapping": {
                  "tag": {
                    "code": "\"lights\""
                  },
                  "value": {
                    "code": "\"on\""
                  }
                },
                "targetOrder": [
                  "tag",
                  "value"
                ],
                "targetElement": "CloudMeta",
                "targetAbility": "setValue"
              }
            ],
            "conditionFalse": [
              {
                "mapping": {
                  "tag": {
                    "code": "\"lights\""
                  },
                  "value": {
                    "code": "\"off\""
                  }
                },
                "targetOrder": [
                  "tag",
                  "value"
                ],
                "targetElement": "CloudMeta",
                "targetAbility": "setValue"
              }
            ]
          }
        },
        {
          "name": "CloudRegister",
          "type": "CloudRegister",
          "variants": [
            "cloud"
          ],
          "properties": {
            "errorData": null
          },
          "meta": {
            "editorX": 583,
            "editorY": 181,
            "lastTrigger": "registered"
          },
          "triggers": {
            "triggered": [],
            "registered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "CloudMeta",
                "targetAbility": "setStatusGood"
              }
            ]
          }
        }
      ],
      "layout": {
        "height": 1000,
        "width": 1000,
        "zIndexOrder": []
      }
    }
  }
}